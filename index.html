<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>勤怠・日報比較ツール (Ver.11.17.21)</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  
  <!-- Babel (JSX変換用) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- SheetJS (Excel操作用) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  
  <style>
    html, body, #root {
      height: 100%;
      overflow: hidden;
    }
    body {
      background-color: #f8fafc; /* bg-slate-50 */
    }
    /* モーダル用のアニメーション */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .modal-overlay {
      animation: fadeIn 0.2s ease-out;
    }
    /* スクロールバーのカスタマイズ */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #f1f5f9;
    }
    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }
    /* テーブル行の高さ固定用 */
    .row-h {
      height: 1.5rem; /* h-6相当 */
      display: flex;
      align-items: center;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useMemo, useRef, useEffect, useCallback } = React;

    // --- アイコン定義 ---
    const IconWrapper = ({ children, className = "w-5 h-5", ...props }) => (
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>
    );
    const FileText = (p) => <IconWrapper {...p}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" /><polyline points="14 2 14 8 20 8" /><line x1="16" y1="13" x2="8" y2="13" /><line x1="16" y1="17" x2="8" y2="17" /><line x1="10" y1="9" x2="8" y2="9" /></IconWrapper>;
    const Users = (p) => <IconWrapper {...p}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" /><circle cx="9" cy="7" r="4" /><path d="M22 21v-2a4 4 0 0 0-3-3.87" /><path d="M16 3.13a4 4 0 0 1 0 7.75" /></IconWrapper>;
    const CheckCircle2 = (p) => <IconWrapper {...p}><circle cx="12" cy="12" r="10" /><path d="m9 12 2 2 4-4" /></IconWrapper>;
    const ChevronRight = (p) => <IconWrapper {...p}><path d="m9 18 6-6-6-6" /></IconWrapper>;
    const Upload = (p) => <IconWrapper {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" y1="3" x2="12" y2="15" /></IconWrapper>;
    const Loader2 = ({ className, ...p }) => <IconWrapper className={`${className} animate-spin`} {...p}><path d="M21 12a9 9 0 1 1-6.219-8.56" /></IconWrapper>;
    const Zap = (p) => <IconWrapper {...p}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" /></IconWrapper>;
    const Table = (p) => <IconWrapper {...p}><path d="M12 3v18" /><rect width="18" height="18" x="3" y="3" rx="2" /><path d="M3 9h18" /><path d="M3 15h18" /></IconWrapper>;
    const FileSpreadsheet = (p) => <IconWrapper {...p}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" /><polyline points="14 2 14 8 20 8" /><path d="M8 13h2" /><path d="M8 17h2" /><path d="M14 13h2" /><path d="M14 17h2" /></IconWrapper>;
    const X = (p) => <IconWrapper {...p}><path d="M18 6 6 18" /><path d="m6 6 12 12" /></IconWrapper>;
    const Trash2 = (p) => <IconWrapper {...p}><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /><line x1="10" y1="11" x2="10" y2="17" /><line x1="14" y1="11" x2="14" y2="17" /></IconWrapper>;
    const Settings = (p) => <IconWrapper {...p}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconWrapper>;
    const Save = (p) => <IconWrapper {...p}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></IconWrapper>;
    const Download = (p) => <IconWrapper {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></IconWrapper>;
    const AlertTriangle = (p) => <IconWrapper {...p}><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></IconWrapper>;
    const Clock = (p) => <IconWrapper {...p}><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></IconWrapper>;
    const HelpCircle = (p) => <IconWrapper {...p}><circle cx="12" cy="12" r="10" /><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" /><path d="M12 17h.01" /></IconWrapper>;
    const CalendarCheck = (p) => <IconWrapper {...p}><rect width="18" height="18" x="3" y="4" rx="2" ry="2" /><line x1="16" y1="2" x2="16" y2="6" /><line x1="8" y1="2" x2="8" y2="6" /><line x1="3" y1="10" x2="21" y2="10" /><path d="m9 16 2 2 4-4" /></IconWrapper>;
    const FolderInput = (p) => <IconWrapper {...p}><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 2H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"/><path d="M12 10v6"/><path d="M9 13h6"/></IconWrapper>;
    const FileWarning = (p) => <IconWrapper {...p}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" /><polyline points="14 2 14 8 20 8" /><path d="M12 18v-6" /><path d="M12 8h.01" /></IconWrapper>;
    const Copy = (p) => <IconWrapper {...p}><rect width="14" height="14" x="8" y="8" rx="2" ry="2" /><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" /></IconWrapper>;
    const Plus = (p) => <IconWrapper {...p}><path d="M5 12h14" /><path d="M12 5v14" /></IconWrapper>;
    const ArrowRightCircle = (p) => <IconWrapper {...p}><circle cx="12" cy="12" r="10" /><path d="m12 16 4-4-4-4" /><path d="M8 12h8" /></IconWrapper>;

    const useSheetJS = () => {
      const [xlsx, setXlsx] = useState(null);
      useEffect(() => {
        if (window.XLSX) { setXlsx(window.XLSX); return; }
        const interval = setInterval(() => {
          if (window.XLSX) { setXlsx(window.XLSX); clearInterval(interval); }
        }, 100);
        return () => clearInterval(interval);
      }, []);
      return xlsx;
    };

    // --- ヘルパー関数 ---
    const parseSpecialTime = (val) => {
      if (val === null || val === undefined || val === '' || val === '-') return 0;
      const str = String(val).trim().replace(',', '.');
      if (str.includes(':')) {
        const [h, m] = str.split(':').map(Number);
        return !isNaN(h) && !isNaN(m) ? h + (m / 60) : 0;
      }
      const floatVal = parseFloat(str);
      if (isNaN(floatVal)) return 0;
      const hours = Math.floor(floatVal);
      const minutes = Math.round((floatVal - hours) * 100);
      return hours + (minutes / 60);
    };

    const formatSpecialTime = (decimalHours, digits = 2) => {
      if (!decimalHours && decimalHours !== 0) return '-';
      const sign = decimalHours < 0 ? '-' : '';
      const absHours = Math.abs(decimalHours);
      const totalMinutes = Math.round(absHours * 60);
      const normH = Math.floor(totalMinutes / 60);
      const normM = totalMinutes % 60;
      
      if (digits === 1) {
          const integerM = Math.floor(normM / 10);
          return sign + normH + "." + integerM;
      }
      return sign + (normH + (normM / 100)).toFixed(2);
    };
    
    const formatTimeStr = (decimalHours) => {
       if (!decimalHours && decimalHours !== 0) return '';
       let val = decimalHours;
       if (val < 0) val += 24;
       if (val >= 24) val -= 24;
       const h = Math.floor(val);
       const m = Math.round((val - h) * 60);
       return `${h}:${m.toString().padStart(2, '0')}`;
    };

    const normalizeId = (id) => {
      if (!id) return '';
      const halfWidth = String(id).replace(/[０-９]/g, (s) => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
      return halfWidth.replace(/^0+/, '').trim();
    };

    const normalizeName = (name) => {
      if (!name) return '';
      return String(name).replace(/[\s\u3000]+/g, '');
    };

    // --- ヘルプモーダル ---
    const HelpModal = ({ isOpen, onClose }) => {
      if (!isOpen) return null;
      return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 modal-overlay" onClick={onClose}>
          <div className="bg-white rounded-2xl shadow-2xl w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col" onClick={e => e.stopPropagation()}>
            <div className="p-6 border-b flex justify-between items-center bg-slate-50">
              <h2 className="text-xl font-bold flex items-center gap-2 text-indigo-700"><HelpCircle className="w-6 h-6" /> 操作ガイド・判定ルール</h2>
              <button onClick={onClose} className="text-slate-400 hover:text-slate-600"><X className="w-6 h-6" /></button>
            </div>
            <div className="p-8 overflow-y-auto text-sm leading-relaxed text-slate-700 space-y-8">
              <section>
                <h3 className="text-lg font-bold text-slate-800 border-b-2 border-indigo-100 pb-2 mb-3 flex items-center gap-2">1. 取締役の判定ルール (Ver.11.0 New)</h3>
                <div className="bg-amber-50 p-4 rounded-xl border border-amber-100">
                  <p className="mb-2 font-bold text-amber-800">取締役は管理職ルールを継承しつつ、以下の特別ルールが適用されます。</p>
                  <ul className="list-disc list-inside space-y-2 text-amber-900">
                    <li><strong>勤務表が存在しない前提:</strong> 勤務表ファイルがなくても、日報や服務簿からデータを補完して表示します。</li>
                    <li><strong>日報のみある日:</strong> 日報の「所定内」時間を、勤務表・服務簿の所定内として表示します。</li>
                    <li><strong>服務簿がある日:</strong> 服務簿の全データ（ステータス、時間帯、各時間）を勤務表側にコピーして表示します。</li>
                    <li><strong>カレンダー情報の継承:</strong> 他の社員（勤務表がある人）のデータを参照し、土日祝日や加休の情報を適用して色付けします。</li>
                  </ul>
                </div>
              </section>
              <section>
                <h3 className="text-lg font-bold text-slate-800 border-b-2 border-indigo-100 pb-2 mb-3 flex items-center gap-2">2. 対応ファイル形式</h3>
                <div className="bg-slate-50 p-4 rounded-xl border border-slate-100">
                  <ul className="list-disc list-inside space-y-2">
                    <li><strong>勤務表:</strong> <code className="bg-white px-2 py-1 rounded border">.xlsx</code> または <code className="bg-white px-2 py-1 rounded border">.csv</code></li>
                    <li><strong>日報:</strong> <code className="bg-white px-2 py-1 rounded border">.xls</code> または <code className="bg-white px-2 py-1 rounded border">.csv</code></li>
                    <li className="text-indigo-600 font-bold"><strong>服務簿:</strong> <code className="bg-white px-2 py-1 rounded border">服務簿一括出力_*.csv</code></li>
                    <li><strong>保存データの復元:</strong> 本ツールで保存した <code className="bg-white px-2 py-1 rounded border">.xlsx</code> ファイルを読み込むことで、データを復元できます。</li>
                  </ul>
                </div>
              </section>
              <section>
                  <h3 className="text-lg font-bold text-slate-800 border-b-2 border-indigo-100 pb-2 mb-3 flex items-center gap-2">3. 時間の読み取りと計算</h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <h4 className="font-bold text-indigo-600 mb-2">独自フォーマット (60進法)</h4>
                    <p className="mb-2">入力値の小数点は「分」として扱われます。</p>
                    <ul className="list-disc list-inside bg-slate-50 p-3 rounded-lg text-xs space-y-1">
                      <li><strong>2.1</strong> (または 2.10) → <span className="font-bold">2時間10分</span></li>
                      <li><strong>2.3</strong> (または 2.30) → <span className="font-bold">2時間30分</span></li>
                      <li><strong>2.5</strong> (または 2.50) → <span className="font-bold">2時間50分</span></li>
                    </ul>
                  </div>
                  <div>
                    <h4 className="font-bold text-indigo-600 mb-2">勤務表「所定内」の自動計算</h4>
                    <p className="mb-2">勤務表には所定内列がないため、以下の式で算出します。</p>
                    <div className="bg-slate-100 p-3 rounded-lg font-mono text-xs border border-slate-200">
                      所定内 = (終業 - 始業) - 休憩 - 深夜休憩 - 時間外
                    </div>
                    <p className="mt-2 text-xs text-slate-500">※時間年休がある場合：合計8.0hになるなら時間年休を引かずに計算（シフト変更扱い）</p>
                  </div>
                </div>
              </section>
              <section>
                  <h3 className="text-lg font-bold text-slate-800 border-b-2 border-indigo-100 pb-2 mb-3 flex items-center gap-2">4. 服務簿の計算ルール（New）</h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <h4 className="font-bold text-indigo-600 mb-2">一般・管理職（フレックス外）</h4>
                    <p className="mb-2">以下の計算式で所定内時間を算出します。</p>
                    <div className="bg-slate-100 p-3 rounded-lg font-mono text-xs border border-slate-200">
                      所定内 = (終了 - 開始) - 休憩 - 残業 - 時間年休
                    </div>
                    <ul className="list-disc list-inside mt-2 text-xs space-y-1">
                      <li>所定変更なしの日: <strong>9:00〜18:00</strong> (休憩1h) を基準</li>
                      <li>年休(全日)・振休・非番の日は所定内および時間帯を表示しません。</li>
                      <li>残業時は終了時刻を拡張して計算</li>
                      <li>時間年休は所定内計算式で減算（重複計上防止）、深夜は引かない。</li>
                      <li className="font-bold text-indigo-600">時間年休の時刻反映: 所定内の開始/終了時刻に合わせて取得した場合、表示される時間帯を短縮します。</li>
                      <li><strong>自己時間:</strong> 勤務時間・深夜時間・合計に含めません。</li>
                      <li className="font-bold text-indigo-600">週休出(残し･時間外不算入): 時間外ではなく所定内に加算します。</li>
                      <li className="font-bold text-indigo-600">非番勤務: 勤務として扱い、所定内7.0h以外や残業ありの場合はNGとします。</li>
                    </ul>
                  </div>
                  <div>
                    <h4 className="font-bold text-indigo-600 mb-2">フレックス対象者</h4>
                    <p className="mb-2">従来通り、CSVデータの「時間」列等を単純集計します。</p>
                    <p className="text-xs text-rose-600 font-bold mt-1">※種別が「フレックス」の行は、開始-終了の差分(休憩除く)を所定内として計算します。</p>
                  </div>
                </div>
              </section>
              <section>
                <h3 className="text-lg font-bold text-slate-800 border-b-2 border-indigo-100 pb-2 mb-3 flex items-center gap-2">5. 社員属性ごとの判定ロジック</h3>
                <table className="w-full text-left border-collapse text-xs">
                  <thead>
                    <tr className="bg-indigo-50 text-indigo-900">
                      <th className="p-2 border border-indigo-100">属性</th>
                      <th className="p-2 border border-indigo-100">比較方法</th>
                      <th className="p-2 border border-indigo-100">夜業時の特例</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td className="p-2 border border-slate-100 font-bold">一般社員</td>
                      <td className="p-2 border border-slate-100">所定内、残業、深夜を個別に一致確認</td>
                      <td className="p-2 border border-slate-100">
                        <span className="font-bold text-emerald-600">あり</span><br/>
                        夜業日は日報所定内に「+8時間」されるルールに対応。<br/>
                        (差分-8.0hならOK、差分0hなら「8h未記入?」と警告)
                      </td>
                    </tr>
                    <tr>
                      <td className="p-2 border border-slate-100 font-bold">管理職/取締役</td>
                      <td className="p-2 border border-slate-100">所定内、残業、深夜を個別に一致確認</td>
                      <td className="p-2 border border-slate-100">
                        <span className="font-bold text-slate-400">なし</span><br/>
                        夜業があっても所定内は加算されません。<br/>
                        (通常通り厳密に比較します)
                      </td>
                    </tr>
                    <tr>
                      <td className="p-2 border border-slate-100 font-bold">フレックス</td>
                      <td className="p-2 border border-slate-100">
                        <strong>合算比較:</strong><br/>
                        勤務表[所定] vs (日報[所定]＋日報[残業])
                      </td>
                      <td className="p-2 border border-slate-100">
                        <span className="font-bold text-orange-600">残業入力禁止</span><br/>
                        勤務表に残業時間が入力されていたら即NGとします。
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <section>
                <h3 className="text-lg font-bold text-slate-800 border-b-2 border-indigo-100 pb-2 mb-3 flex items-center gap-2">5. 特殊な不整合チェック項目</h3>
                <ul className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <li className="bg-rose-50 p-3 rounded-lg border border-rose-100 text-rose-800">
                      <span className="font-bold block mb-1">■ 日報 H列チェック (H214～221)</span>
                      日報(印刷用形式)の隠しエリア等にある特定セルに「0以外」の値が入っている場合、「H列不整合」として警告を出します。<br/>
                      <span className="text-xs text-rose-600">※フレックス対象者はチェック除外されます。</span>
                    </li>
                    <li className="bg-amber-50 p-3 rounded-lg border border-amber-100 text-amber-800">
                      <span className="font-bold block mb-1">■ 時間年休＋残業の重複</span>
                      勤務表で「時間年休」を取得している日に、「時間外(残業)」も計上されている場合、「年休+残業NG」として警告します。
                    </li>
                    <li className="bg-orange-50 p-3 rounded-lg border border-orange-100 text-orange-800">
                      <span className="font-bold block mb-1">■ 夜業1入力チェック</span>
                      ・日報F列(深夜)が7.0、かつH列(夜業)が1なら「夜業1OK」<br/>
                      ・F列が7.0でH列が1でない場合「夜業1NG」<br/>
                      ・F列が7.0でないのにH列に1がある場合は「H列不整合」<br/>
                      <span className="text-xs text-rose-600">※管理職は夜業時のH列1入力不要（入力あるとNG）。非番もNG。</span>
                    </li>
                    <li className="bg-blue-50 p-3 rounded-lg border border-blue-100 text-blue-800">
                      <span className="font-bold block mb-1">■ 振休取得チェック</span>
                      土曜非番（＝振休発生）回数と、振休取得回数が一致しているかチェックします。（週休出はチェック対象外となりました）
                    </li>
                </ul>
              </section>
              <section>
                <h3 className="text-lg font-bold text-slate-800 border-b-2 border-indigo-100 pb-2 mb-3 flex items-center gap-2">6. 設定機能の使い方</h3>
                <div className="space-y-3">
                  <p>画面右上の「設定」ボタンから、以下の項目を登録・保存できます。</p>
                  <ul className="list-disc list-inside ml-4 space-y-1">
                    <li><strong>管理職リスト:</strong> 夜業時の8h加算を行わない対象者。</li>
                    <li><strong>フレックス対象者:</strong> 残業合算比較を行う対象者。</li>
                    <li><strong>旧姓マッピング:</strong> 日報(旧姓)と勤務表(新姓)を自動的に紐付けるための対照表。</li>
                  </ul>
                  <div className="flex gap-4 mt-2">
                    <div className="flex-1 bg-slate-50 p-3 rounded text-xs">
                      <strong>保存 (Export):</strong><br/>
                      現在の設定内容を <code>attendance_settings.json</code> というファイルに書き出します。次回利用時に読み込むことで設定を復元できます。
                    </div>
                    <div className="flex-1 bg-slate-50 p-3 rounded text-xs">
                      <strong>読込 (Import):</strong><br/>
                      保存しておいたJSONファイルを読み込み、設定を反映させます。読み込み後、表示中のデータは即座に再計算されます。
                    </div>
                  </div>
                </div>
              </section>
            </div>
            <div className="p-6 border-t bg-slate-50 text-right">
              <button onClick={onClose} className="px-8 py-3 bg-indigo-600 text-white font-bold rounded-xl hover:bg-indigo-700 shadow-lg shadow-indigo-200 transition-all">閉じる</button>
            </div>
          </div>
        </div>
      );
    };

    // --- 設定モーダル ---
    const SettingsModal = ({ isOpen, onClose, settings, onSave, onClear, onExportNextMonth }) => {
      const [managersText, setManagersText] = useState('');
      const [directorsText, setDirectorsText] = useState('');
      const [flexText, setFlexText] = useState('');
      const [mappings, setMappings] = useState([]);
      const [compBalances, setCompBalances] = useState([]);
      const fileInput = useRef(null);

      useEffect(() => {
        if (isOpen) {
          setManagersText(settings.managers.join('\n'));
          setDirectorsText(settings.directors ? settings.directors.join('\n') : '');
          setFlexText(settings.flexEmployees ? settings.flexEmployees.join('\n') : '');
          setMappings(settings.nameMappings);
          // 振休残データのロード (Map形式から配列形式へ)
          const balances = settings.compensatoryLeaveBalances || {};
          setCompBalances(Object.entries(balances).map(([name, days]) => ({ name, days })));
        }
      }, [isOpen, settings]);

      const handleSave = () => {
        const newManagers = managersText.split('\n').map(s => normalizeName(s)).filter(s => s);
        const newDirectors = directorsText.split('\n').map(s => normalizeName(s)).filter(s => s);
        const newFlex = flexText.split('\n').map(s => normalizeName(s)).filter(s => s);
        
        // 振休残データを配列からMap形式に戻す
        const newBalances = {};
        compBalances.forEach(b => {
          if (b.name && !isNaN(parseFloat(b.days))) {
            newBalances[normalizeName(b.name)] = parseFloat(b.days);
          }
        });

        onSave({
          managers: newManagers,
          directors: newDirectors,
          flexEmployees: newFlex,
          nameMappings: mappings.filter(m => m.nippo && m.kintai),
          compensatoryLeaveBalances: newBalances
        });
        onClose();
      };

      const handleClear = () => {
        if (window.confirm('保存されている設定をすべて削除し、初期状態に戻しますか？')) {
          onClear();
          onClose();
        }
      };

      const addMapping = () => setMappings([...mappings, { nippo: '', kintai: '' }]);
      const updateMapping = (idx, field, val) => {
        const newMappings = [...mappings];
        newMappings[idx][field] = val;
        setMappings(newMappings);
      };
      const removeMapping = (idx) => setMappings(mappings.filter((_, i) => i !== idx));

      // 振休残数管理用
      const addBalance = () => setCompBalances([...compBalances, { name: '', days: 0 }]);
      const updateBalance = (idx, field, val) => {
        const newBalances = [...compBalances];
        newBalances[idx][field] = val;
        setCompBalances(newBalances);
      };
      const removeBalance = (idx) => setCompBalances(compBalances.filter((_, i) => i !== idx));

      const exportSettings = () => {
        const balances = {};
        compBalances.forEach(b => {
             if (b.name) balances[normalizeName(b.name)] = parseFloat(b.days);
        });

        const data = {
          managers: managersText.split('\n').map(s => s.trim()).filter(s => s),
          directors: directorsText.split('\n').map(s => s.trim()).filter(s => s),
          flexEmployees: flexText.split('\n').map(s => s.trim()).filter(s => s),
          nameMappings: mappings,
          compensatoryLeaveBalances: balances
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'attendance_settings.json';
        a.click();
      };

      const importSettings = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const data = JSON.parse(ev.target.result);
            onSave(data);
            if (data.managers) setManagersText(data.managers.join('\n'));
            if (data.directors) setDirectorsText(data.directors.join('\n'));
            if (data.flexEmployees) setFlexText(data.flexEmployees.join('\n'));
            if (data.nameMappings) setMappings(data.nameMappings);
            if (data.compensatoryLeaveBalances) {
                setCompBalances(Object.entries(data.compensatoryLeaveBalances).map(([name, days]) => ({ name, days })));
            } else {
                setCompBalances([]);
            }
          } catch (err) { alert('設定ファイルの読み込みに失敗しました。'); }
        };
        reader.readAsText(file);
      };

      if (!isOpen) return null;

      return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 modal-overlay">
          <div className="bg-white rounded-2xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
            <div className="p-6 border-b flex justify-between items-center bg-slate-50">
              <h2 className="text-lg font-bold flex items-center gap-2"><Settings className="w-5 h-5" />詳細設定</h2>
              <button onClick={onClose} className="text-slate-400 hover:text-slate-600"><X className="w-5 h-5" /></button>
            </div>
            <div className="p-6 overflow-y-auto flex-1 space-y-8">
              <div className="flex gap-3 pb-6 border-b">
                <button onClick={exportSettings} className="flex items-center gap-2 px-3 py-2 text-sm font-bold text-indigo-600 bg-indigo-50 rounded-lg hover:bg-indigo-100 transition-colors"><Download className="w-4 h-4" /> 設定を保存(Export)</button>
                <button onClick={() => fileInput.current.click()} className="flex items-center gap-2 px-3 py-2 text-sm font-bold text-slate-600 bg-slate-100 rounded-lg hover:bg-slate-200 transition-colors"><Upload className="w-4 h-4" /> 設定を読込(Import)</button>
                <input type="file" ref={fileInput} className="hidden" accept=".json" onChange={importSettings} />
              </div>
              <div className="grid grid-cols-2 gap-6">
                <div>
                  <h3 className="font-bold text-sm text-slate-700 mb-2">管理職リスト</h3>
                  <textarea value={managersText} onChange={e => setManagersText(e.target.value)} className="w-full h-32 p-3 border rounded-xl text-sm font-mono focus:ring-2 focus:ring-indigo-500 outline-none bg-slate-50" placeholder="氏名(1行1名)" />
                </div>
                <div>
                  <h3 className="font-bold text-sm text-slate-700 mb-2">取締役リスト <span className="text-[10px] text-amber-600 bg-amber-50 px-1 rounded ml-1">NEW</span></h3>
                  <textarea value={directorsText} onChange={e => setDirectorsText(e.target.value)} className="w-full h-32 p-3 border rounded-xl text-sm font-mono focus:ring-2 focus:ring-amber-500 outline-none bg-slate-50" placeholder="氏名(1行1名)" />
                </div>
                <div>
                  <h3 className="font-bold text-sm text-slate-700 mb-2">フレックス対象者</h3>
                  <textarea value={flexText} onChange={e => setFlexText(e.target.value)} className="w-full h-32 p-3 border rounded-xl text-sm font-mono focus:ring-2 focus:ring-indigo-500 outline-none bg-slate-50" placeholder="氏名(1行1名)" />
                </div>
              </div>
              
              <div>
                <h3 className="font-bold text-sm text-slate-700 mb-2">振替休日・残数管理 (期首残)</h3>
                <p className="text-xs text-slate-500 mb-2">前月からの繰越日数（未消化分）を設定します。<br/><span className="text-indigo-500">※解析済みの場合、社員名が自動補完されることはありませんが、下記「次月用設定保存」ボタンで自動計算・出力が可能です。</span></p>
                <div className="space-y-2 max-h-40 overflow-y-auto border p-2 rounded-xl bg-slate-50">
                    {compBalances.map((b, i) => (
                        <div key={i} className="flex gap-2 items-center">
                            <input value={b.name} onChange={e => updateBalance(i, 'name', e.target.value)} placeholder="氏名" className="flex-1 p-2 border rounded-lg text-sm bg-white" />
                            <input type="number" step="0.5" value={b.days} onChange={e => updateBalance(i, 'days', e.target.value)} placeholder="残日数" className="w-20 p-2 border rounded-lg text-sm bg-white" />
                            <button onClick={() => removeBalance(i)} className="text-rose-400 hover:text-rose-600"><Trash2 className="w-4 h-4" /></button>
                        </div>
                    ))}
                    <button onClick={addBalance} className="flex items-center gap-1 text-xs font-bold text-indigo-600 hover:underline mt-2"><Plus className="w-3 h-3"/> 追加する</button>
                </div>
              </div>

              <div>
                <h3 className="font-bold text-sm text-slate-700 mb-2">旧姓・別名マッピング</h3>
                <div className="space-y-2">
                  {mappings.map((m, i) => (
                    <div key={i} className="flex gap-2 items-center">
                      <input value={m.nippo} onChange={e => updateMapping(i, 'nippo', e.target.value)} placeholder="日報(旧姓)" className="flex-1 p-2 border rounded-lg text-sm bg-slate-50" />
                      <span className="text-slate-400">→</span>
                      <input value={m.kintai} onChange={e => updateMapping(i, 'kintai', e.target.value)} placeholder="勤務表(新姓)" className="flex-1 p-2 border rounded-lg text-sm bg-slate-50" />
                      <button onClick={() => removeMapping(i)} className="text-rose-400 hover:text-rose-600"><Trash2 className="w-4 h-4" /></button>
                    </div>
                  ))}
                  <button onClick={addMapping} className="text-xs font-bold text-indigo-600 hover:underline">+ 追加する</button>
                </div>
              </div>
            </div>
            <div className="flex justify-between items-center p-4 border-t bg-slate-50">
              <div className="flex gap-4 items-center">
                  <button onClick={handleClear} className="text-rose-500 text-sm font-bold hover:underline flex items-center gap-1"><Trash2 className="w-4 h-4"/> 初期化</button>
                  <button onClick={onExportNextMonth} className="text-indigo-600 text-sm font-bold hover:underline flex items-center gap-1 bg-indigo-50 px-3 py-1 rounded-lg border border-indigo-100 hover:bg-indigo-100 transition-colors" title="現在の計算結果（期末残）を来月の期首残として保存します"><ArrowRightCircle className="w-4 h-4"/> 次月用設定保存(繰越)</button>
              </div>
              <div className="flex gap-3">
                <button onClick={onClose} className="px-4 py-2 text-sm font-bold text-slate-500 hover:bg-slate-200 rounded-lg">キャンセル</button>
                <button onClick={handleSave} className="px-6 py-2 text-sm font-bold text-white bg-indigo-600 hover:bg-indigo-700 rounded-lg shadow-lg shadow-indigo-200">設定を適用</button>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // --- NG詳細モーダル ---
    const NgDetailModal = ({ isOpen, onClose, title, items, employeeName, allItems }) => {
      if (!isOpen) return null;

      const handleCopy = () => {
        const header = `${employeeName} 様\n下記のチェックで不整合が出ていますので修正をお願いいたします。\n\n`;
        
        let body = '';
        if (allItems && allItems.length > 0) {
            body = allItems.map(cat => {
                const catHeader = `【${cat.category}】\n`;
                const catBody = cat.items.map(i => `・${i.date} ${i.message}`).join('\n');
                return catHeader + catBody;
            }).join('\n\n');
        } else {
             body = `${title}\n` + items.map(i => `${i.date} ${i.message}`).join('\n');
        }
        
        const text = header + body;
        
        const textArea = document.createElement("textarea");
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand('copy');
          alert('コピーしました');
          onClose(); // コピー後自動で閉じる
        } catch (err) {
          alert('コピーに失敗しました');
        }
        document.body.removeChild(textArea);
      };

      return (
        <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/50 modal-overlay" onClick={onClose}>
          <div className="bg-white rounded-2xl shadow-2xl w-full max-w-lg max-h-[80vh] flex flex-col" onClick={e => e.stopPropagation()}>
            <div className="p-4 border-b flex justify-between items-center bg-rose-50 rounded-t-2xl">
              <h3 className="font-bold text-rose-800 flex items-center gap-2"><AlertTriangle className="w-5 h-5"/> {title}</h3>
              <button onClick={onClose}><X className="w-5 h-5 text-rose-400"/></button>
            </div>
            <div className="p-4 overflow-y-auto flex-1">
              <table className="w-full text-sm text-left">
                <thead className="text-xs text-slate-500 border-b">
                  <tr><th className="pb-2">日付</th><th className="pb-2">内容</th></tr>
                </thead>
                <tbody className="divide-y">
                  {items.map((item, idx) => (
                    <tr key={idx}>
                      <td className="py-2 font-mono font-bold text-slate-700 whitespace-nowrap pr-4">{item.date}</td>
                      <td className="py-2 text-rose-600">{item.message}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
              {items.length === 0 && <p className="text-slate-400 text-center py-4">詳細なNG箇所を特定できませんでした（集計不一致など）</p>}
            </div>
            <div className="p-4 border-t bg-slate-50 rounded-b-2xl flex justify-end">
              <button onClick={handleCopy} className="flex items-center gap-2 px-4 py-2 bg-slate-800 text-white rounded-lg hover:bg-slate-700 text-sm font-bold">
                <Copy className="w-4 h-4"/> コピー
              </button>
            </div>
          </div>
        </div>
      );
    };

    class AttendanceFileParser {
      constructor(xlsx) { 
        this.xlsx = xlsx; 
        this.tempMap = {}; 
      }

      async parseFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = new Uint8Array(e.target.result);
              const workbook = this.xlsx.read(data, { type: 'array', cellDates: false, codepage: 932, cellFormula: false });
              resolve({ workbook, fileName: file.name });
            } catch (error) { reject(error); }
          };
          reader.readAsArrayBuffer(file);
        });
      }

      getOrInitEntry(name, id, sourceType, settings) {
        let normName = normalizeName(name);
        let displayName = name;

        if (settings && settings.nameMappings) {
            const mapping = settings.nameMappings.find(m => 
              normalizeName(m.kintai) === normName || normalizeName(m.nippo) === normName
            );
            if (mapping) {
              normName = normalizeName(mapping.nippo);
              displayName = mapping.nippo;
            }
        }

        if (!normName) return null;

        if (!this.tempMap[normName]) {
          this.tempMap[normName] = {
            normalizedName: normName,
            displayName: displayName, 
            ids: { service: null, schedule: null, report: null },
            schedule: [],
            report: [],
            serviceRecord: [],
            rawServiceData: { name: name, days: {} },
            warnings: []
          };
        }
        
        const entry = this.tempMap[normName];
        
        if (id) {
            const normId = normalizeId(id);
            if (sourceType === 'service') entry.ids.service = normId;
            if (sourceType === 'schedule') entry.ids.schedule = normId;
            if (sourceType === 'report') entry.ids.report = normId;
        }
        
        const isMapped = settings && settings.nameMappings && settings.nameMappings.some(m => normalizeName(m.nippo) === normName);
        if (!isMapped && sourceType === 'service' && name) {
            entry.displayName = name;
        }

        return entry;
      }

      upsertRecord(array, record) {
        const idx = array.findIndex(r => r.day === record.day);
        if (idx >= 0) {
          const existing = array[idx];
          array[idx] = {
            ...existing, ...record,
            regularTime: (existing.regularTime || 0) + (record.regularTime || 0),
            overtime: (existing.overtime || 0) + (record.overtime || 0),
            nightTime: (existing.nightTime || 0) + (record.nightTime || 0),
            holidayWork: (existing.holidayWork || 0) + (record.holidayWork || 0),
            status: record.status || existing.status,
            weekday: record.weekday || existing.weekday, 
            startTime: record.startTime || existing.startTime,
            endTime: record.endTime || existing.endTime,
            timeAnnualLeave: record.timeAnnualLeave || existing.timeAnnualLeave,
            nightWorkVal: record.nightWorkVal || existing.nightWorkVal,
            special: record.special || existing.special,
            types: record.types ? [...new Set([...(existing.types||[]), ...record.types])] : (existing.types || [])
          };
          if (record.timeAnnualLeaveDetails) {
              existing.timeAnnualLeaveDetails = existing.timeAnnualLeaveDetails 
                ? existing.timeAnnualLeaveDetails + ", " + record.timeAnnualLeaveDetails
                : record.timeAnnualLeaveDetails;
          }
        } else { 
            array.push(record); 
        }
      }

      upsertServiceRecord(array, record) {
        const idx = array.findIndex(r => r.day === record.day);
        if (idx >= 0) {
            array[idx] = record;
        } else {
            array.push(record);
        }
      }

      extractYearMonth(rows) {
        for (let i = 0; i < 50 && i < rows.length; i++) {
          const rowStr = (rows[i] || []).join(' ');
          const m = rowStr.match(/(\d{4})[\u5e74/](\d{1,2})/); 
          if (m) {
            return `${m[1]}${m[2].padStart(2, '0')}`;
          }
        }
        return null;
      }

      async processFiles(files, settings) {
        this.tempMap = {};
        let detectedYearMonth = null;
        let restoredSettings = null;

        for (const file of files) {
          try {
            const { workbook, fileName } = await this.parseFile(file);
            
            // Check for saved Excel file (Metadata sheet)
            if (workbook.SheetNames.includes("_Metadata")) {
               const metaSheet = workbook.Sheets["_Metadata"];
               const metaRows = this.xlsx.utils.sheet_to_json(metaSheet, {header: 1});
               
               const getVal = (key) => {
                   const row = metaRows.find(r => r[0] === key);
                   return row ? row[1] : null;
               };
               
               const settingsJsonM = getVal("Settings_Managers");
               const settingsJsonD = getVal("Settings_Directors"); // Added
               const settingsJsonF = getVal("Settings_Flex");
               const settingsJsonN = getVal("Settings_Mappings");
               const settingsJsonC = getVal("Settings_CompensatoryBalances"); // 新規追加
               
               if (settingsJsonM || settingsJsonD || settingsJsonF || settingsJsonN || settingsJsonC) {
                   restoredSettings = {
                       managers: settingsJsonM ? JSON.parse(settingsJsonM) : settings.managers,
                       directors: settingsJsonD ? JSON.parse(settingsJsonD) : settings.directors, // Added
                       flexEmployees: settingsJsonF ? JSON.parse(settingsJsonF) : settings.flexEmployees,
                       nameMappings: settingsJsonN ? JSON.parse(settingsJsonN) : settings.nameMappings,
                       compensatoryLeaveBalances: settingsJsonC ? JSON.parse(settingsJsonC) : settings.compensatoryLeaveBalances
                   };
                   settings = restoredSettings;
               }
               
               workbook.SheetNames.forEach(sheetName => {
                   if (sheetName === "_Metadata") return;
                   const sheet = workbook.Sheets[sheetName];
                   const sheetRows = this.xlsx.utils.sheet_to_json(sheet, {header: 1});
                   const result = this.parseRestoredSheet(sheetRows, settings);
                   if (result && result.yearMonth && !detectedYearMonth) {
                       detectedYearMonth = result.yearMonth;
                   }
               });
               
               continue;
            }

            const rows = this.xlsx.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]], { header: 1, defval: '', raw: false });
            
            if (!detectedYearMonth) {
              detectedYearMonth = this.extractYearMonth(rows);
            }

            let isSchedule = false;
            if (fileName.includes('勤務表')) {
               const m1Val = (rows.length > 0 && rows[0] && rows[0][12]) ? String(rows[0][12]) : '';
               if (m1Val.includes('勤')) isSchedule = true;
            }

            if (isSchedule) {
              this.parseSchedule(rows, settings);
            } else if (fileName.includes('服務簿')) {
              this.parseServiceRecord(rows, settings);
            } else {
              const contentStr = rows.slice(0, 15).map(r => r.join(' ')).join(' ');
              const isDailyReportData = contentStr.includes('工事番号') && contentStr.includes('所定内') && !contentStr.includes('行番号');
              
              if (isDailyReportData) {
                this.parseDailyReport_DataFormat(rows, settings);
              } else {
                this.parseDailyReport_PrintFormat(rows, settings);
              }
            }
          } catch (e) { alert(`ファイル読み込みエラー: ${file.name}\n${e.message}`); console.error(e); }
        }
        
        Object.values(this.tempMap).forEach(entry => {
            const tempSvc = entry.rawServiceData;
            if (tempSvc && Object.keys(tempSvc.days).length > 0) {
                const normName = entry.normalizedName;
                let isFlex = settings.flexEmployees.includes(normName);
                if (settings.nameMappings) {
                      const m = settings.nameMappings.find(map => normalizeName(map.nippo) === normName || normalizeName(map.kintai) === normName);
                      if (m) {
                          const kn = normalizeName(m.kintai);
                          if (settings.flexEmployees.includes(kn)) isFlex = true;
                      }
                }

                const hasFlexInRaw = Object.values(tempSvc.days).some(dayRecords => 
                    dayRecords.some(r => r.type === 'フレックス')
                );
                if (hasFlexInRaw) {
                    isFlex = true;
                    entry.warnings = entry.warnings.filter(w => w !== 'H列不整合');
                }

                Object.keys(tempSvc.days).forEach(dayKey => {
                    const day = parseInt(dayKey, 10);
                    const records = tempSvc.days[dayKey];
                    const aggregated = this.aggregateServiceRecord(null, day, records, isFlex);
                    this.upsertServiceRecord(entry.serviceRecord, aggregated);
                });
            }
        });

        const finalEmployees = {};
        Object.values(this.tempMap).forEach(entry => {
            let finalId = entry.ids.service || entry.ids.schedule || entry.ids.report || `TEMP-${entry.normalizedName}`;
            if (finalEmployees[finalId]) {
                finalId = `${finalId}_${entry.normalizedName}`;
            }
            finalEmployees[finalId] = {
                employeeId: finalId,
                employeeName: entry.displayName,
                schedule: entry.schedule,
                report: entry.report,
                serviceRecord: entry.serviceRecord,
                warnings: entry.warnings
            };
        });

        return { employees: finalEmployees, meta: { yearMonth: detectedYearMonth }, restoredSettings };
      }

      parseRestoredSheet(rows, settings) {
          let empName = "";
          let empId = "";
          let yearMonth = null; 

          for(let i=0; i<15; i++) {
              if (rows[i] && rows[i].length > 0) {
                  const cell0 = String(rows[i][0] || "");
                  const cell1 = String(rows[i][1] || "");
                  if (cell0.startsWith("社員名:")) empName = cell0.substring(4).trim();
                  if (cell1.startsWith("ID:")) empId = cell1.substring(3).trim();
                  if (cell0.startsWith("対象年月:")) {
                      const match = cell0.match(/対象年月:\s*(\d+)/);
                      if (match) yearMonth = match[1];
                  }
              }
          }
          if (!empName) return null;

          const entry = this.getOrInitEntry(empName, empId, 'service', settings);
          
          let headerRow = -1;
          for(let i=0; i<rows.length; i++) {
              if (rows[i] && rows[i][0] === "日付" && String(rows[i][2]).includes("勤務表")) {
                  headerRow = i;
                  break;
              }
          }
          if (headerRow === -1) return { yearMonth };

          for(let i=headerRow+1; i<rows.length; i++) {
              const row = rows[i];
              const day = parseInt(row[0]);
              if (isNaN(day)) continue;

              const schTimeParts = String(row[3] || "").split("-");
              let schStatus = String(row[2] || "");
              schStatus = schStatus.replace(/,?\s*時間年休/g, "").trim();
              if(schStatus.startsWith(",")) schStatus = schStatus.substring(1).trim();

              this.upsertRecord(entry.schedule, {
                  day: day,
                  weekday: row[1],
                  status: schStatus,
                  startTime: schTimeParts[0] || "",
                  endTime: schTimeParts[1] || "",
                  regularTime: parseSpecialTime(row[4]),
                  overtime: parseSpecialTime(row[5]),
                  nightTime: parseSpecialTime(row[6]),
                  timeAnnualLeave: parseSpecialTime(row[7])
              });

              const svcTimeParts = String(row[9] || "").split("-");
              const rawSvcStatus = String(row[8] || "");
              const svcItems = rawSvcStatus.split(",").map(s => s.trim()).filter(s => s);
              const sysStatusItems = svcItems.filter(s => s.includes("承認") || s.includes("反映"));
              const sysStatus = sysStatusItems.join(", ");
              const typeItems = svcItems.filter(s => !s.includes("承認") && !s.includes("反映"));
              
              const svcDivergenceStr = String(row[14] || ""); 
              const hasDivergence = svcDivergenceStr.includes('乖離');

              this.upsertServiceRecord(entry.serviceRecord, {
                  day: day,
                  status: sysStatus,
                  startTime: svcTimeParts[0] || "",
                  endTime: svcTimeParts[1] || "",
                  regularTime: parseSpecialTime(row[10]),
                  overtime: parseSpecialTime(row[11]),
                  nightTime: parseSpecialTime(row[12]),
                  timeAnnualLeave: parseSpecialTime(row[13]),
                  types: typeItems,
                  hasDivergence: hasDivergence
              });

              let repStatus = String(row[15] || ""); 
              let repStartTime = row[16] || "";      
              this.upsertRecord(entry.report, {
                  day: day,
                  status: repStatus,
                  startTime: repStartTime, 
                  regularTime: parseSpecialTime(row[17]),
                  overtime: parseSpecialTime(row[18]),
                  nightTime: parseSpecialTime(row[19]),
                  nightWorkVal: row[20] || "",
                  holidayWork: (repStatus.includes("休出")) ? 1 : 0 
              });
          }
          
          return { yearMonth };
      }

      parseServiceRecord(rows, settings) {
        let colMap = null;
        let headerRowIdx = -1;
        for (let i = 0; i < 20 && i < rows.length; i++) {
            const row = rows[i];
            const rowStr = row.join(',');
            if (rowStr.includes('申請者No') && rowStr.includes('ステータス') && rowStr.includes('種別')) {
                headerRowIdx = i;
                colMap = {
                    no: row.findIndex(c => String(c).includes('申請者No')),
                    name: row.findIndex(c => String(c).includes('申請者氏名')),
                    date: row.findIndex(c => String(c) === '日付'),
                    type: row.findIndex(c => String(c) === '種別'),
                    start: row.findIndex(c => String(c) === '開始時刻'),
                    end: row.findIndex(c => String(c) === '終了時刻'),
                    time: row.findIndex(c => String(c) === '時間'),
                    breakTime: row.findIndex(c => String(c) === '休憩時間'),
                    nightTime: row.findIndex(c => String(c) === '深夜時間'),
                    status: row.findIndex(c => String(c) === 'ステータス'),
                    cancel: row.findIndex(c => String(c) === '取消区分'),
                    divergence: row.findIndex(c => String(c).includes('乖離')) // 乖離列の特定
                };
                if (colMap.divergence === -1) colMap.divergence = 16; // 見つからなければQ列(index 16)をデフォルトとする
                break;
            }
        }
        if (headerRowIdx === -1 || !colMap) return;

        for (let i = headerRowIdx + 1; i < rows.length; i++) {
            const row = rows[i];
            if (!row || row.length < 5) continue;

            if (colMap.cancel !== -1) {
                const cancelVal = String(row[colMap.cancel] || '').trim();
                if (cancelVal === '取消') continue;
            }

            const empId = row[colMap.no];
            const empName = row[colMap.name];
            if (!empName) continue;

            const entry = this.getOrInitEntry(empName, empId, 'service', settings);
            if (!entry) continue;

            const dateStr = String(row[colMap.date] || '');
            let dayVal = 0;
            const dayMatch = dateStr.match(/(\d+)日/);
            if (dayMatch) dayVal = parseInt(dayMatch[1], 10);
            else continue;

            // 乖離チェック
            let hasDivergence = false;
            if (colMap.divergence !== -1 && row[colMap.divergence]) {
                const divVal = String(row[colMap.divergence]).trim();
                // "乖離有（申請要）" と完全一致する場合のみNGとする
                if (divVal === '乖離有（申請要）') {
                    hasDivergence = true;
                }
            }

            if (!entry.rawServiceData.days[dayVal]) {
                entry.rawServiceData.days[dayVal] = [];
            }
            entry.rawServiceData.days[dayVal].push({
                type: String(row[colMap.type] || '').trim(),
                time: String(row[colMap.time] || ''),
                startTime: String(row[colMap.start] || '').trim(),
                endTime: String(row[colMap.end] || '').trim(),
                breakTime: String(row[colMap.breakTime] || ''),
                nightTime: String(row[colMap.nightTime] || ''),
                status: String(row[colMap.status] || '').trim(),
                hasDivergence: hasDivergence
            });
        }
      }

      parseSchedule(rows, settings) {
        let currentEntry = null;
        let colMap = null;
        for (let i = 0; i < rows.length; i++) {
          const row = rows[i] || [];
          const rowStr = row.join(' ');
          if (rowStr.includes('社員番号')) {
            const idMatch = rowStr.match(/社員番号[\s:：]*(\d{5,10})/);
            if (idMatch) {
              const rawName = rowStr.match(/(?:氏名|氏　名)[\s:：]*([^\s,0-9]+(?:\s+[^\s,0-9]+)?)/)?.[1];
              currentEntry = this.getOrInitEntry(rawName, idMatch[1], 'schedule', settings);
            }
          }
          if (!colMap && (row.includes('日付') || row.includes('勤務状況'))) {
            colMap = {
              day: row.findIndex(c => c && c.includes('日付')),
              weekday: row.findIndex(c => c && c.includes('曜日')),
              status: row.findIndex(c => c && c.includes('勤務状況')),
              start: row.findIndex(c => c && (c.includes('始業') || c.includes('開始'))),
              end: row.findIndex(c => c && (c.includes('終業') || c.includes('終了'))),
              breakTime: row.findIndex(c => c && c.includes('休憩') && !c.includes('深夜')),
              nightBreak: row.findIndex(c => c && c.includes('深夜') && c.includes('休憩')),
              overtime: row.findIndex(c => c && c.includes('時間外') && !c.includes('法内') && !c.includes('深夜')),
              night: row.findIndex(c => c && c.includes('深夜') && !c.includes('休憩')),
              special: 3, 
              timeAnnualLeave: 14 
            };
            const spIdx = row.findIndex(c => c && c.includes('特殊'));
            if (spIdx !== -1) colMap.special = spIdx;
            if (colMap.day === -1) colMap.day = 0;
            if (colMap.weekday === -1) colMap.weekday = 1;
            continue;
          }
          if (currentEntry && colMap) {
            const colA = String(row[colMap.day] || '').trim();
            if (colA === '合計') { currentEntry = null; continue; }
            const dayVal = parseInt(colA, 10);
            if (!isNaN(dayVal) && dayVal >= 1 && dayVal <= 31) {
              const startStr = row[colMap.start];
              const endStr = row[colMap.end];
              const breakTime = parseSpecialTime(row[colMap.breakTime]);
              const nightBreakTime = parseSpecialTime(row[colMap.nightBreak]);
              const overtime = parseSpecialTime(row[colMap.overtime]);
              const timeAnnualLeave = parseSpecialTime(row[colMap.timeAnnualLeave]);
              const weekdayStr = String(row[colMap.weekday] || '').trim();
              
              let regularTime = 0;
              if (startStr && endStr) {
                let s = parseSpecialTime(startStr);
                let e = parseSpecialTime(endStr);
                if (e < s) e += 24;
                const actualWork = (e - s) - breakTime - nightBreakTime;
                if (timeAnnualLeave > 0) {
                  if (Math.abs((actualWork + timeAnnualLeave) - 8.0) < 0.01) regularTime = actualWork;
                  else regularTime = Math.max(0, actualWork - timeAnnualLeave);
                } else {
                  regularTime = Math.max(0, actualWork - overtime);
                }
              }
              this.upsertRecord(currentEntry.schedule, {
                day: dayVal, weekday: weekdayStr, status: String(row[colMap.status] || ''),
                startTime: startStr ? String(startStr) : '', endTime: endStr ? String(endStr) : '',
                overtime, regularTime, timeAnnualLeave, nightTime: parseSpecialTime(row[colMap.night]),
                special: String(row[colMap.special] || '')
              });
            }
          }
        }
      }

      parseDailyReport_DataFormat(rows, settings) {
        let currentEntry = null;
        let colMap = null;
        let headerRowIdx = -1;
        for (let i = 0; i < 20 && i < rows.length; i++) {
          const row = rows[i];
          if (!currentEntry) {
            const idIdx = row.findIndex(c => String(c).includes('社員番号'));
            const nameIdx = row.findIndex(c => String(c).includes('社員名'));
            if (idIdx !== -1 && row[idIdx + 1]) {
              const rawName = (nameIdx !== -1 && row[nameIdx + 1]) ? String(row[nameIdx + 1]) : '';
              currentEntry = this.getOrInitEntry(rawName, row[idIdx + 1], 'report', settings);
            }
          }
          if (row.includes('工事番号') && row.includes('所定内')) {
            headerRowIdx = i;
            colMap = {
              day: row.findIndex(c => c === '日'),
              regular: row.findIndex(c => c.includes('所定内')),
              overtime: row.findIndex(c => c.includes('時間外')),
              night: row.findIndex(c => c.includes('深夜')),
              holiday: row.findIndex(c => c.includes('休日')),
              nightWork: row.findIndex(c => c.includes('夜業'))
            };
            break;
          }
        }
        if (!currentEntry || !colMap) return;
        
        for (let i = headerRowIdx + 1; i < rows.length; i++) {
          const row = rows[i];
          if (!row) continue;
          const dayVal = parseInt(row[colMap.day], 10);
          if (!isNaN(dayVal) && dayVal >= 1 && dayVal <= 31) {
            const regular = parseSpecialTime(row[colMap.regular]);
            const overtime = parseSpecialTime(row[colMap.overtime]);
            const holiday = parseSpecialTime(row[colMap.holiday]);
            const valF = parseSpecialTime(row[colMap.night]);
            let valH_Raw = row[colMap.nightWork];
            if (valH_Raw === undefined || valH_Raw === null) valH_Raw = '';
            let nightWorkVal = '';
            const sH = String(valH_Raw).trim();
            if (sH !== '' && sH !== '0' && sH !== '0.0') nightWorkVal = sH;

            this.upsertRecord(currentEntry.report, {
              day: dayVal, regularTime: regular, overtime: overtime,
              nightTime: valF, holidayWork: holiday,
              status: (regular > 0 || overtime > 0 || holiday > 0) ? '出勤' : '',
              startTime: '記録あり', nightWorkVal
            });
          }
        }
      }

      parseDailyReport_PrintFormat(rows, settings) {
        let currentEntry = null;
        let COL = { DATE: 3, REGULAR: 26, OVERTIME: 29, NIGHT: 32, HOLIDAY: 35, NAME: 32, AM: 38 };
        let rawName = '';
        let dataStartRow = 10;
        for (let i = 0; i < 20; i++) {
          const row = rows[i];
          if (!row) continue;
          const findCol = (regex) => row.findIndex(c => regex.test(String(c)));
          const colReg = findCol(/所\s*定\s*内/);
          if (colReg > 0) {
            COL.REGULAR = colReg;
            const colHoli = findCol(/休\s*日/);
            if (colHoli > 0) { COL.HOLIDAY = colHoli; COL.AM = colHoli + 3; } 
            else { COL.HOLIDAY = colReg + 9; COL.AM = COL.HOLIDAY + 3; }
            const colOver = findCol(/時\s*間\s*外/);
            if (colOver > 0) COL.OVERTIME = colOver;
            const colNight = findCol(/深\s*夜/);
            if (colNight > 0) COL.NIGHT = colNight;
            dataStartRow = i + 1;
            break;
          }
        }

        if (rows[7] && rows[7][COL.NAME]) rawName = String(rows[7][COL.NAME]);
        let rawId = null;
        for (let i = 0; i < 10; i++) {
          const rowStr = (rows[i] || []).join(' ');
          const idMatch = rowStr.match(/社員番号[\s:：]*(\d{5,10})/);
          if (idMatch) { rawId = idMatch[1]; break; }
        }
        currentEntry = this.getOrInitEntry(rawName, rawId, 'report', settings);
        if (!currentEntry) return;

        const isFlex = settings.flexEmployees.includes(currentEntry.normalizedName) || (settings.nameMappings && settings.nameMappings.some(m => normalizeName(m.nippo) === currentEntry.normalizedName && settings.flexEmployees.includes(normalizeName(m.kintai))));
        
        if (!isFlex) {
          for(let r = 213; r <= 220; r++) {
            if (rows[r] && parseFloat(rows[r][7]) !== 0 && !isNaN(parseFloat(rows[r][7]))) {
              if (!currentEntry.warnings.includes('H列不整合')) currentEntry.warnings.push('H列不整合');
            }
          }
        }

        for (let i = dataStartRow; i < rows.length; i++) {
          const row = rows[i];
          const dayValRaw = row[COL.DATE];
          if (dayValRaw == 0 || dayValRaw === '0') break;
          const dayVal = parseInt(dayValRaw, 10);
          if (!isNaN(dayVal) && dayVal >= 1 && dayVal <= 31) {
            const regular = parseSpecialTime(row[COL.REGULAR]);
            const overtime = parseSpecialTime(row[COL.OVERTIME]);
            const holiday = parseSpecialTime(row[colMap?.HOLIDAY] || row[COL.HOLIDAY]);
            let amRaw = row[COL.AM];
            if (amRaw === undefined || amRaw === null) amRaw = '';
            const amStr = String(amRaw).trim().replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
            let nightWorkVal = '';
            if (amStr !== '' && amStr !== '0' && amStr !== '0.0') nightWorkVal = amStr;
            
            this.upsertRecord(currentEntry.report, {
              day: dayVal, regularTime: regular, overtime: overtime,
              nightTime: parseSpecialTime(row[COL.NIGHT]), holidayWork: holiday, nightWorkVal,
              status: (regular > 0 || overtime > 0 || holiday > 0) ? '出勤' : '', startTime: '記録あり'
            });
          }
        }
      }

      aggregateServiceRecord(empId, day, records, isFlexEmployee) {
          const hasFlexRecord = records.some(r => r.type === 'フレックス');
          const isFlexMode = isFlexEmployee || hasFlexRecord;
          const hasNightWorkType = records.some(r => r.type && r.type.includes('夜業'));
          const hasDivergence = records.some(r => r.hasDivergence);

          if (isFlexMode) {
              let regularTime = 0;
              let overtime = 0;
              let nightTime = 0;
              let timeAnnualLeave = 0;
              let timeAnnualLeaveDetails = [];
              let startTime = null;
              let endTime = null;
              let types = [];
              let status = '';
              
              records.forEach(r => {
                  if (r.type.includes('自己時間')) {
                      if (r.type) types.push(r.type);
                      if (r.status) status = r.status;
                      return; 
                  }
                  if (r.type) types.push(r.type);
                  if (r.status) status = r.status;
                  
                  if (r.type === 'その他休') {
                  } else if (r.type.includes('週休出') && r.type.includes('不算入')) {
                        regularTime += parseSpecialTime(r.time);
                  } else if (r.type.includes('時間外') || r.type.includes('休日')) {
                        overtime += parseSpecialTime(r.time);
                  } else if (r.type.includes('時間年休')) {
                        timeAnnualLeave += parseSpecialTime(r.time);
                        if (r.startTime && r.endTime) timeAnnualLeaveDetails.push(`${r.startTime}-${r.endTime}`);
                  } else if (r.type === 'フレックス') {
                        regularTime += parseSpecialTime(r.time);
                  } else {
                        regularTime += parseSpecialTime(r.time);
                  }
                  nightTime += parseSpecialTime(r.nightTime);
                  
                  if (r.startTime) {
                      const t = parseSpecialTime(r.startTime);
                      if (startTime === null || t < parseSpecialTime(startTime)) startTime = r.startTime;
                  }
                  if (r.endTime) {
                      const t = parseSpecialTime(r.endTime);
                      if (endTime === null || t > parseSpecialTime(endTime)) endTime = r.endTime;
                  }
              });

              // --- 追加ロジック: 時刻補完 ---
              // フレックス対象者で、開始・終了時刻の記載がなく、かつ全休等の休暇種別でない場合は 9:00-18:00 とみなす
              const hasAbsenceType = types.some(t => {
                  // 時間年休、半休、出勤系(週休出)は勤務とみなすため、ここでの除外対象（休暇）とはしない
                  if (t.includes('時間年休') || t.includes('半休') || t.includes('出') || t.includes('フレックス')) return false;
                  // 年休、欠勤、振休、特休、有給、公休 などが含まれていれば休暇とみなす
                  return t.includes('休') || t.includes('欠勤') || t.includes('有給') || t.includes('休暇');
              });

              if (!startTime && !endTime && !hasAbsenceType) {
                  startTime = '9:00';
                  endTime = '18:00';
                  // 修正: 所定内時間が0の場合（かつ通常の出勤日扱い）、8.0hとみなす
                  if (regularTime === 0) regularTime = 8.0; 
              }
              // ---------------------------

              if (hasNightWorkType) nightTime += 7.0;
              
              return {
                  day, regularTime, overtime, nightTime, timeAnnualLeave,
                  timeAnnualLeaveDetails: timeAnnualLeaveDetails.join(', '),
                  startTime: startTime || '', endTime: endTime || '',
                  status, types: [...new Set(types)],
                  hasDivergence
              };
          } else {
              // 修正：「忌引休」を追加して全日休暇の判定に含める
              const isFullDayLeave = records.some(r => r.type === '年休' || r.type === '全日年休' || r.type === '有給休暇' || r.type === 'その他休' || r.type === '忌引休');
              // 修正: 「非番勤務」は休日（休暇）として扱わない
              const isCompensatoryDay = records.some(r => r.type.includes('振休') || r.type.includes('振替休日') || (r.type.includes('非番') && !r.type.includes('非番勤務')));

              const halfDayRecord = records.find(r => r.type && r.type.includes('半休'));
              const changeRecord = records.find(r => r.type === '所定時間変更');
              
              let startVal = 9.0;
              let endVal = 18.0;
              let breakVal = 1.0;
              
              const baseRecord = halfDayRecord || changeRecord;
              
              if (baseRecord) {
                  if (baseRecord.startTime) startVal = parseSpecialTime(baseRecord.startTime);
                  if (baseRecord.endTime) endVal = parseSpecialTime(baseRecord.endTime);
                  if (baseRecord.breakTime) breakVal = parseSpecialTime(baseRecord.breakTime);
                  else if (halfDayRecord) breakVal = 0;
              }
              
              let overtime = 0;
              let nightTime = 0;
              let timeAnnualLeave = 0;
              let weekHolidayTime = 0;
              let timeAnnualLeaveDetails = [];
              let types = [];
              let status = '';

              // 週休出の実時間記録用
              let weekHolidayStart = null;
              let weekHolidayEnd = null;
              
              // 非番勤務の実時間記録用
              let hibanKinmuStart = null;
              let hibanKinmuEnd = null;
              let hibanKinmuTime = 0;

              records.forEach(r => {
                  if (r.type.includes('自己時間')) {
                      if (r.type) types.push(r.type);
                      if (r.status) status = r.status;
                      return; 
                  }
                  if (r.type) types.push(r.type);
                  if (r.status) status = r.status;
                  
                  if (r.type.includes('週休出') && r.type.includes('不算入')) {
                      weekHolidayTime += parseSpecialTime(r.time);
                      // 週休出の開始・終了時間を取得
                      if (r.startTime) {
                          const t = parseSpecialTime(r.startTime);
                          if (weekHolidayStart === null || t < weekHolidayStart) weekHolidayStart = t;
                      }
                      if (r.endTime) {
                          let t = parseSpecialTime(r.endTime);
                          // 日をまたぐ場合の考慮（開始より終了が小さい場合、24足すなど）
                          // ここでは単純比較のため、startTimeと比較して補正
                          if (r.startTime) {
                              const s = parseSpecialTime(r.startTime);
                              if (t < s) t += 24.0;
                          }
                          if (weekHolidayEnd === null || t > weekHolidayEnd) weekHolidayEnd = t;
                      }
                  } else if (r.type.includes('非番勤務')) { // 非番勤務の集計を追加
                      hibanKinmuTime += parseSpecialTime(r.time);
                      if (r.startTime) {
                          const t = parseSpecialTime(r.startTime);
                          if (hibanKinmuStart === null || t < hibanKinmuStart) hibanKinmuStart = t;
                      }
                      if (r.endTime) {
                          let t = parseSpecialTime(r.endTime);
                          if (r.startTime) {
                              const s = parseSpecialTime(r.startTime);
                              if (t < s) t += 24.0;
                          }
                          if (hibanKinmuEnd === null || t > hibanKinmuEnd) hibanKinmuEnd = t;
                      }
                  } else if (r.type.includes('時間外') || r.type.includes('休日')) {
                      overtime += parseSpecialTime(r.time);
                      if (r.endTime) {
                          let tEnd = parseSpecialTime(r.endTime);
                          if (tEnd < startVal) tEnd += 24.0;
                          if (tEnd > endVal) endVal = tEnd;
                      }
                      if (r.startTime) {
                          let tStart = parseSpecialTime(r.startTime);
                          if (tStart < startVal && tStart > 0) startVal = tStart;
                      }
                  }
                  
                  if (r.type.includes('時間年休')) {
                      timeAnnualLeave += parseSpecialTime(r.time);
                      if (r.startTime && r.endTime) timeAnnualLeaveDetails.push(`${r.startTime}-${r.endTime}`);
                      
                      if (r.startTime && r.endTime) {
                          const tStart = parseSpecialTime(r.startTime);
                          const tEnd = parseSpecialTime(r.endTime);
                          if (Math.abs(tStart - startVal) < 0.01) startVal = tEnd;
                          else if (Math.abs(tEnd - endVal) < 0.01) endVal = tStart;
                      }
                  }
                  nightTime += parseSpecialTime(r.nightTime);
              });
              
              let calcStart = 9.0;
              let calcEnd = 18.0;
              if (baseRecord) {
                  if (baseRecord.startTime) calcStart = parseSpecialTime(baseRecord.startTime);
                  if (baseRecord.endTime) calcEnd = parseSpecialTime(baseRecord.endTime);
              }
              records.forEach(r => {
                  if (r.type.includes('自己時間')) return;
                  if (r.type.includes('週休出') && r.type.includes('不算入')) {
                  } else if (r.type.includes('時間外') || r.type.includes('休日')) {
                      if (r.endTime) {
                          let tEnd = parseSpecialTime(r.endTime);
                          if (tEnd < calcStart) tEnd += 24.0;
                          if (tEnd > calcEnd) calcEnd = tEnd;
                      }
                      if (r.startTime) {
                          let tStart = parseSpecialTime(r.startTime);
                          if (tStart < calcStart && tStart > 0) calcStart = tStart;
                      }
                  }
              });
              
              if (calcEnd < calcStart) calcEnd += 24.0;
              const totalDuration = calcEnd - calcStart;
              let regularTime = totalDuration - breakVal - overtime - timeAnnualLeave;
              regularTime = Math.max(0, regularTime);
              
              let finalRegularTime = regularTime;
              let finalStartTime = formatTimeStr(startVal);
              let finalEndTime = formatTimeStr(endVal);
              
              if (isFullDayLeave || isCompensatoryDay) {
                  finalRegularTime = 0;
                  finalStartTime = '';
                  finalEndTime = '';
              }

              if (weekHolidayTime > 0) {
                  finalRegularTime = weekHolidayTime;
                  // 週休出がある場合、時間を上書き
                  if (weekHolidayStart !== null) finalStartTime = formatTimeStr(weekHolidayStart);
                  if (weekHolidayEnd !== null) finalEndTime = formatTimeStr(weekHolidayEnd);
              }
              
              // 非番勤務がある場合、時間を上書き
              if (hibanKinmuTime > 0) {
                  finalRegularTime = hibanKinmuTime;
                  if (hibanKinmuStart !== null) finalStartTime = formatTimeStr(hibanKinmuStart);
                  if (hibanKinmuEnd !== null) finalEndTime = formatTimeStr(hibanKinmuEnd);
              }

              if (hasNightWorkType) nightTime += 7.0;

              return {
                  day, regularTime: finalRegularTime, overtime, nightTime, timeAnnualLeave,
                  timeAnnualLeaveDetails: timeAnnualLeaveDetails.join(', '),
                  startTime: finalStartTime, endTime: finalEndTime,
                  status, types: [...new Set(types)],
                  hasDivergence
              };
          }
      }
    }

    const STORAGE_KEY = 'attendance_tool_settings_v9';

    function App() {
      const [files, setFiles] = useState([]);
      const [isProcessing, setIsProcessing] = useState(false);
      const [employees, setEmployees] = useState({}); 
      const [fileMeta, setFileMeta] = useState({}); 
      const [selectedId, setSelectedId] = useState(null);
      const [view, setView] = useState('input');
      const [showSettings, setShowSettings] = useState(false);
      const [showHelp, setShowHelp] = useState(false);
      const [checkMode, setCheckMode] = useState('full');
      // settingsにcompensatoryLeaveBalancesを追加
      const [settings, setSettings] = useState({ managers: [], directors: [], flexEmployees: [], nameMappings: [], compensatoryLeaveBalances: {} });
      const [mismatchListOpen, setMismatchListOpen] = useState(false);
      const [missingListOpen, setMissingListOpen] = useState(false); 
      const [ngDetailData, setNgDetailData] = useState(null);
      const fileInputRef = useRef(null);
      const folderInputRef = useRef(null);
      const xlsx = useSheetJS();

      useEffect(() => {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            try {
                const parsedSettings = JSON.parse(saved);
                if (!parsedSettings.directors) parsedSettings.directors = [];
                if (!parsedSettings.compensatoryLeaveBalances) parsedSettings.compensatoryLeaveBalances = {};
                setSettings(parsedSettings);
            } catch (e) { console.error("設定の読み込みに失敗しました", e); }
        }
      }, []);

      useEffect(() => {
        if (folderInputRef.current) {
          folderInputRef.current.setAttribute('webkitdirectory', '');
          folderInputRef.current.setAttribute('directory', '');
        }
      }, [view]);

      const onFileChange = (e) => setFiles(prev => [...prev, ...Array.from(e.target.files || [])]);
      const removeFile = (index) => setFiles(prev => prev.filter((_, i) => i !== index));

      const recalcEmployees = useCallback((currentEmployees, newSettings) => {
        const newMap = {};
        
        const mergeRecordArrays = (arr1, arr2) => {
          const result = [...arr1];
          arr2.forEach(item => {
            const idx = result.findIndex(r => r.day === item.day);
            if (idx >= 0) {
              const ex = result[idx];
              result[idx] = {
                ...ex,
                ...item,
                regularTime: (ex.regularTime || 0) + (item.regularTime || 0),
                overtime: (ex.overtime || 0) + (item.overtime || 0),
                nightTime: (ex.nightTime || 0) + (item.nightTime || 0),
                holidayWork: (ex.holidayWork || 0) + (item.holidayWork || 0),
                timeAnnualLeave: (ex.timeAnnualLeave || 0) + (item.timeAnnualLeave || 0),
                status: item.status || ex.status,
                startTime: item.startTime || ex.startTime,
                endTime: item.endTime || ex.endTime,
                nightWorkVal: item.nightWorkVal || ex.nightWorkVal,
                special: item.special || ex.special,
                types: [...new Set([...(ex.types || []), ...(item.types || [])])],
                timeAnnualLeaveDetails: [ex.timeAnnualLeaveDetails, item.timeAnnualLeaveDetails].filter(Boolean).join(", "),
                hasDivergence: ex.hasDivergence || item.hasDivergence
              };
            } else {
              result.push(item);
            }
          });
          return result;
        };

        Object.values(currentEmployees).forEach(emp => {
          let normName = normalizeName(emp.employeeName);
          let targetName = emp.employeeName;
          
          if (newSettings.nameMappings) {
            const mapping = newSettings.nameMappings.find(m => 
              normalizeName(m.kintai) === normName || normalizeName(m.nippo) === normName
            );
            if (mapping) {
              normName = normalizeName(mapping.nippo);
              targetName = mapping.nippo;
            }
          }
          
          const groupKey = normName;
          
          if (!newMap[groupKey]) {
            newMap[groupKey] = {
              employeeId: emp.employeeId,
              employeeName: targetName,
              schedule: emp.schedule,
              report: emp.report,
              serviceRecord: emp.serviceRecord,
              warnings: emp.warnings || []
            };
          } else {
            const target = newMap[groupKey];
            target.schedule = mergeRecordArrays(target.schedule, emp.schedule);
            target.report = mergeRecordArrays(target.report, emp.report);
            target.serviceRecord = mergeRecordArrays(target.serviceRecord, emp.serviceRecord);
            if (emp.warnings) {
              emp.warnings.forEach(w => {
                if (!target.warnings.includes(w)) target.warnings.push(w);
              });
            }
          }
        });
        
        const finalObj = {};
        Object.values(newMap).forEach(e => {
          finalObj[e.employeeId] = e;
        });
        return finalObj;
      }, []);

      const handleSaveSettings = (newSettings) => {
        setSettings(newSettings);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(newSettings));
        setEmployees(prev => recalcEmployees(prev, newSettings));
      };

      const handleClearSettings = () => {
          const defaultSettings = { managers: [], directors: [], flexEmployees: [], nameMappings: [], compensatoryLeaveBalances: {} };
          setSettings(defaultSettings);
          localStorage.removeItem(STORAGE_KEY);
          setEmployees(prev => recalcEmployees(prev, defaultSettings));
      };

      // 振休情報計算関数
      const calculateCompensatoryInfo = (emp, settings) => {
          const normName = normalizeName(emp.employeeName);
          const initialStock = settings.compensatoryLeaveBalances && settings.compensatoryLeaveBalances[normName] ? settings.compensatoryLeaveBalances[normName] : 0;
          
          let earned = 0;
          let used = 0;

          const serviceMap = {};
          emp.serviceRecord.forEach(s => serviceMap[s.day] = s);
          
          // 全日リストアップ (1-31)
          for (let day = 1; day <= 31; day++) {
             const sch = emp.schedule.find(s => s.day === day) || {};
             const svc = emp.serviceRecord.find(s => s.day === day) || {};
             
             // 発生: 服務簿優先、なければ勤務表
             let isEarned = false;
             if (svc.types && svc.types.some(t => t.includes('週休出') && t.includes('不算入'))) {
                 isEarned = true;
             } else if (!svc.status && sch.status && sch.status.includes('週休出') && sch.status.includes('不算入')) {
                 // 勤務表のステータス文字列に依存（仮実装）
                 isEarned = true;
             }
             if (isEarned) earned++;

             // 消化: 振休 or 振替休日
             // 服務簿
             let isUsed = false;
             if (svc.types && svc.types.some(t => t.includes('振休') || t.includes('振替休日'))) {
                 isUsed = true;
             } else if (svc.status && (svc.status.includes('振休') || svc.status.includes('振替休日'))) {
                 isUsed = true;
             } 
             // 勤務表
             if (!isUsed) {
                 if (sch.status && (sch.status.includes('振休') || sch.status.includes('振替休日'))) {
                     isUsed = true;
                 }
             }
             if (isUsed) used++;
          }

          const finalStock = initialStock + earned - used;
          const warningUnused = initialStock > 0 && used < initialStock;
          const warningShortage = finalStock < 0;

          return { initialStock, earned, used, finalStock, warningUnused, warningShortage };
      };

      const handleExportNextMonthSettings = () => {
          const newBalances = {};
          Object.values(employees).forEach(emp => {
              const info = calculateCompensatoryInfo(emp, settings);
              const normName = normalizeName(emp.employeeName);
              newBalances[normName] = info.finalStock;
          });

          const nextSettings = {
              ...settings,
              compensatoryLeaveBalances: newBalances
          };

          const blob = new Blob([JSON.stringify(nextSettings, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'attendance_settings_next_month.json';
          a.click();
      };

      const checkDailyMismatch = (sch, rep, svc, isManager, isFlex, nextDaySch, nextDaySvc) => {
        const isPending = svc.status && String(svc.status).includes('承認待ち');
        const isNotReflected = svc.status && String(svc.status).includes('実績反映なし');
        const hasSvcData = Boolean(svc.status || svc.startTime || svc.regularTime > 0 || svc.overtime > 0 || svc.nightTime > 0 || svc.timeAnnualLeave > 0);
        
        const shouldUseSvc = isPending || isNotReflected || hasSvcData;
        const base = shouldUseSvc ? svc : sch;

        const nextIsPending = nextDaySvc && String(nextDaySvc.status).includes('承認待ち');
        const nextIsNotReflected = nextDaySvc && String(nextDaySvc.status).includes('実績反映なし');
        const nextHasSvcData = nextDaySvc && Boolean(nextDaySvc.status || nextDaySvc.startTime);
        const nextShouldUseSvc = nextIsPending || nextIsNotReflected || nextHasSvcData;
        const nextBase = nextShouldUseSvc ? nextDaySvc : nextDaySch;

        let diffOvertime = (base.overtime || 0) - (rep.overtime || 0);
        let diffRegular = (base.regularTime || 0) - (rep.regularTime || 0);
        let diffNight = (base.nightTime || 0) - (rep.nightTime || 0);
        
        let isSpecialCase = false;
        let warningMessage = '';
        let hasMismatch = false;

        const isNightWorkF7 = Math.abs((rep.nightTime || 0) - 7.0) < 0.01;
        const hVal = parseFloat(rep.nightWorkVal || '0');
        const hasH1 = Math.abs(hVal - 1.0) < 0.01;
        
        let nightWorkCheckOK = null;
        let nightWorkCheckNG = null;
        let nightWorkMessage = '';

        if (isManager) {
            if (isNightWorkF7) {
                if (hasH1) {
                    nightWorkMessage = '日報夜業チェック不要';
                    hasMismatch = true;
                }
            }
            if (!isNightWorkF7 && hasH1) {
                nightWorkMessage = 'H列不整合';
                hasMismatch = true;
            }
            const isHiban = base.types ? base.types.some(t => t.includes('非番') && !t.includes('非番勤務')) : (base.status && base.status.includes('非番') && !base.status.includes('非番勤務'));
            if (isHiban) {
                warningMessage = warningMessage ? warningMessage + ' 非番NG' : '非番NG';
                hasMismatch = true;
            }
        } else {
            if (isNightWorkF7) {
                if (hasH1) nightWorkCheckOK = true; 
                else { nightWorkCheckNG = true; hasMismatch = true; }
            }
            if (!isNightWorkF7 && hasH1) {
                 nightWorkMessage = 'H列不整合'; 
                 hasMismatch = true;
            }
        }

        // 非番勤務の特例チェック
        const isHibanKinmu = base.types ? base.types.some(t => t.includes('非番勤務')) : (base.status && base.status.includes('非番勤務'));
        if (isHibanKinmu) {
            // 所定内7.0チェック
            if (Math.abs((base.regularTime || 0) - 7.0) > 0.01) {
                 warningMessage = warningMessage ? warningMessage + ' 非番勤務所定≠7' : '非番勤務所定≠7';
                 hasMismatch = true;
            }
            // 時間外チェック
            if ((base.overtime || 0) > 0.01) {
                 warningMessage = warningMessage ? warningMessage + ' 非番勤務残業NG' : '非番勤務残業NG';
                 hasMismatch = true;
            }
        }

        // 半休取得時の時刻チェック (Ver.11.17.9)
        if (svc.types && svc.types.some(t => t.includes('半休'))) {
            const startH = parseSpecialTime(svc.startTime);
            const endH = parseSpecialTime(svc.endTime);
            // 終了時刻が開始より小さい場合は日跨ぎとみなして24加算
            const endH_adj = endH < startH ? endH + 24.0 : endH;

            // 半休(後半): 15:00 - 18:00
            if (svc.types.some(t => t.includes('後半') || t.includes('午後'))) {
                const ngStart = 15.0; // 変更: 13.0 -> 15.0
                const ngEnd = 18.0;
                // 重複判定: max(start, ngStart) < min(end, ngEnd)
                const overlapStart = Math.max(startH, ngStart);
                const overlapEnd = Math.min(endH_adj, ngEnd);
                if (overlapStart < overlapEnd) {
                    warningMessage = warningMessage ? warningMessage + ' 半休(後半)時刻NG' : '半休(後半)時刻NG';
                    hasMismatch = true;
                }
            }
            // 半休(午前): 8:00 - 10:00
            else if (svc.types.some(t => t.includes('午前') || t.includes('前半'))) {
                const ngStart = 8.0;
                const ngEnd = 10.0; // 変更: 11.0 -> 10.0
                const overlapStart = Math.max(startH, ngStart);
                const overlapEnd = Math.min(endH_adj, ngEnd);
                if (overlapStart < overlapEnd) {
                    warningMessage = warningMessage ? warningMessage + ' 半休(午前)時刻NG' : '半休(午前)時刻NG';
                    hasMismatch = true;
                }
            }
        }

        // 深夜残業チェック
        const svcEndTimeVal = parseSpecialTime(svc.endTime);
        // 服務簿の種別またはステータスに「夜業」が含まれているか
        const isSvcNightWork = (svc.types && svc.types.some(t => t.includes('夜業'))) || (svc.status && svc.status.includes('夜業'));
        let lateNightOvertimeNG = false;

        // 夜業以外 かつ 終了時刻が22時以降
        if (!isSvcNightWork && svcEndTimeVal > 22.0) {
            // 服務簿の深夜時間(N列相当) と 日報の深夜時間(F列相当) を比較
            // svc.nightTime vs rep.nightTime
            if (Math.abs((svc.nightTime || 0) - (rep.nightTime || 0)) > 0.01) {
                lateNightOvertimeNG = true;
                warningMessage = warningMessage ? warningMessage + ' 深夜残業NG' : '深夜残業NG';
                hasMismatch = true;
            }
        }

        let nextDayCheckOK = true;
        if (!isManager && isNightWorkF7) {
           if (nextBase) {
             const nextWeekday = nextDaySch ? nextDaySch.weekday : '';
             if (!String(nextWeekday).includes('土')) {
                 const isNextHiban = nextBase.types ? nextBase.types.some(t => t.includes('非番')) : (nextBase.status && nextBase.status.includes('非番'));
                 if (!isNextHiban) {
                   warningMessage = warningMessage ? warningMessage + ' 翌非番NG' : '翌非番NG';
                   hasMismatch = true;
                   nextDayCheckOK = false;
                 }
             }
           }
        }

        if (base.timeAnnualLeave > 0 && base.overtime > 0) {
          warningMessage = warningMessage ? warningMessage + ' 年休+残業' : '年休+残業';
          hasMismatch = true;
        }

        if (isFlex) {
          if (base.overtime > 0) { warningMessage = 'FLEX残業NG'; hasMismatch = true; }
          const flexRegularDiff = (base.regularTime || 0) - ((rep.regularTime || 0) + (rep.overtime || 0));
          if (Math.abs(flexRegularDiff) > 0.01) hasMismatch = true;
          if (!hasMismatch) { diffRegular = 0; isSpecialCase = false; } else { diffRegular = flexRegularDiff; }
          diffOvertime = 0;
        } else {
          const hasNightWorkInReport = isNightWorkF7;
          if (!isManager && hasNightWorkInReport) {
            if (Math.abs(diffRegular + 8.0) < 0.1) { diffRegular = 0; isSpecialCase = true; } 
            else if (Math.abs(diffRegular) < 0.1) { warningMessage = '所定8h未記入?'; hasMismatch = true; }
            else { hasMismatch = true; }
          } else {
            if (Math.abs(diffRegular) > 0.01) hasMismatch = true;
          }
          if (Math.abs(diffOvertime) > 0.01) hasMismatch = true;
        }
        if (Math.abs(diffNight) > 0.01) hasMismatch = true;

        let statusBadge = null;
        if (isPending) statusBadge = '承認待ち';
        else if (isNotReflected) statusBadge = '実績反映なし';

        return { 
            diffRegular, diffOvertime, diffNight, isSpecialCase, warningMessage, hasMismatch, 
            nextDayCheckOK, isNightWorkDay: isNightWorkF7, nightWorkCheckOK, nightWorkCheckNG, nightWorkMessage,
            statusBadge, base, lateNightOvertimeNG
        };
      };

      const analyzeEmployeeMismatch = (emp, isManager, isFlex, limitDay, masterSchedule, isDirector) => {
        if (!isFlex && emp.warnings && emp.warnings.includes('H列不整合')) return true;
        let hasError = false;
        let nightWorkCount = 0;
        let hibanCount = 0;
        let compensatoryLeaveCount = 0;
        let saturdayHibanCount = 0;
        let saturdayHibanCheckNG = false;
        let lateNightOvertimeNG = false;

        const scheduleMap = {};
        emp.schedule.forEach(s => scheduleMap[s.day] = s);
        const serviceMap = {};
        emp.serviceRecord.forEach(s => serviceMap[s.day] = s);

        for (let day = 1; day <= limitDay; day++) {
          const originalSch = scheduleMap[day] || {};
          const rep = emp.report.find(r => r.day === day) || {};
          const originalSvc = serviceMap[day] || {};
          
          let sch = { ...originalSch };
          let svc = { ...originalSvc };
          
          if (!sch.weekday && masterSchedule.length > 0) {
              const masterDay = masterSchedule.find(m => m.day === day);
              if (masterDay) {
                  sch.weekday = masterDay.weekday;
                  if (isDirector) sch.status = masterDay.status; 
              }
          }

          const hasSvcData = svc.status || svc.startTime || svc.endTime || (svc.regularTime > 0) || (svc.overtime > 0) || (svc.nightTime > 0) || (svc.timeAnnualLeave > 0);
          if (!hasSvcData) {
              if (sch.status || sch.startTime || (sch.regularTime > 0)) {
                  svc.startTime = sch.startTime;
                  svc.endTime = sch.endTime;
                  svc.regularTime = sch.regularTime;
                  svc.overtime = sch.overtime;
                  svc.nightTime = sch.nightTime; 
                  svc.timeAnnualLeave = sch.timeAnnualLeave; 
                  svc.status = '勤務表から転記';
              }
          }

          if (isDirector) {
              const hasSvc = Boolean(originalSvc.status || originalSvc.startTime);
              const hasRep = Boolean(rep.regularTime > 0 || rep.status);

              if (hasSvc) {
                  sch.status = originalSvc.status;
                  sch.startTime = originalSvc.startTime;
                  sch.endTime = originalSvc.endTime;
                  sch.regularTime = originalSvc.regularTime;
                  sch.overtime = originalSvc.overtime;
                  sch.nightTime = originalSvc.nightTime;
              } else if (!hasSvc && hasRep) {
                  svc.regularTime = rep.regularTime;
                  svc.status = '日報参照'; 
                  sch.regularTime = rep.regularTime;
                  sch.status = '日報参照';
              }
          }

          if (sch.status || rep.status || svc.status || sch.overtime > 0 || rep.overtime > 0 || svc.startTime || sch.regularTime > 0 || rep.regularTime > 0) {
            const nextDaySch = scheduleMap[day+1];
            const nextDaySvc = serviceMap[day+1];

            const res = checkDailyMismatch(sch, rep, svc, isManager, isFlex, nextDaySch, nextDaySvc);
            if (res.hasMismatch) { hasError = true; }
            if (res.lateNightOvertimeNG) { lateNightOvertimeNG = true; hasError = true; }
            
            const base = res.base;
            
            const hasSvcNightWork = (svc.types && svc.types.some(t => t.includes('夜業'))) || (svc.status && svc.status.includes('夜業'));
            if (hasSvcNightWork) nightWorkCount++;

            const isHiban = base.types ? base.types.some(t => t.includes('非番')) : (base.status && base.status.includes('非番'));
            if (isHiban) hibanCount++;
            
            if (base.types && base.types.some(t => t.includes('振休') || t.includes('振替休日'))) compensatoryLeaveCount++;
            else if (!base.types && base.status && (base.status.includes('振休') || base.status.includes('振替休日'))) compensatoryLeaveCount++;
            
            const weekday = sch.weekday || '';
            const isSat = weekday.includes('土');
            const isSvcHiban = svc.types ? svc.types.some(t => t.includes('非番')) : (svc.status && svc.status.includes('非番'));
            
            if (isSat && isSvcHiban) {
                saturdayHibanCount++;
                const mondaySvc = serviceMap[day+2] || {};
                const hasMondayTarget = (mondaySvc.types && mondaySvc.types.some(t => (t.includes('週休出') && t.includes('不算入')) || t.includes('振休') || t.includes('振替休日')))
                                      || (!mondaySvc.types && mondaySvc.status && (mondaySvc.status.includes('振休') || mondaySvc.status.includes('振替休日')));
                if (!hasMondayTarget) saturdayHibanCheckNG = true;
            }
          }
        }
        
        if (!isManager) {
            if (nightWorkCount !== hibanCount) hasError = true;
        }
        if (saturdayHibanCheckNG) hasError = true;
        
        // 振休残チェック
        const compInfo = calculateCompensatoryInfo(emp, settings);
        if (compInfo.warningUnused || compInfo.warningShortage) hasError = true;

        return hasError;
      };

      const employeeSummary = useMemo(() => {
        const list = Object.values(employees);
        let directorCount = 0;
        let managerCount = 0;
        let generalCount = 0;
        let flexCount = 0;
        let mismatchEmployees = [];
        let missingReportEmployees = []; 
        const limitDay = checkMode === 'day20' ? 20 : 31;
        
        const masterSchedule = list.find(e => e.schedule.length > 0)?.schedule || [];

        list.forEach(emp => {
          let currentName = normalizeName(emp.employeeName);
          let isManager = settings.managers.includes(currentName);
          let isDirector = settings.directors && settings.directors.includes(currentName);
          let isFlex = settings.flexEmployees.includes(currentName);
          
          if (settings.nameMappings) {
            const mapping = settings.nameMappings.find(m => normalizeName(m.nippo) === currentName || normalizeName(m.kintai) === currentName);
            if (mapping) {
                currentName = normalizeName(mapping.nippo);
                const kintaiName = normalizeName(mapping.kintai);
                if (settings.managers.includes(currentName) || settings.managers.includes(kintaiName)) isManager = true;
                if (settings.directors && (settings.directors.includes(currentName) || settings.directors.includes(kintaiName))) isDirector = true;
                if (settings.flexEmployees.includes(currentName) || settings.flexEmployees.includes(kintaiName)) isFlex = true;
            }
          }

          if (!isFlex && emp.serviceRecord && emp.serviceRecord.some(r => r.types && r.types.includes('フレックス'))) {
              isFlex = true;
          }

          if (isDirector) {
              directorCount++;
          } else if (isFlex) {
              flexCount++;
          } else if (isManager) {
              managerCount++; 
          } else {
              generalCount++;
          }
          
          if (analyzeEmployeeMismatch(emp, isManager || isDirector, isFlex, limitDay, masterSchedule, isDirector)) mismatchEmployees.push(emp);

          const hasService = emp.serviceRecord.length > 0;
          const hasSchedule = emp.schedule.length > 0;
          const hasReport = emp.report.some(r => r.status || r.regularTime > 0 || r.overtime > 0);
          
          if ((hasService || hasSchedule) && !hasReport) {
              missingReportEmployees.push(emp);
          }
        });
        return { directorCount, managerCount, generalCount, flexCount, mismatchEmployees, missingReportEmployees };
      }, [employees, settings, checkMode]);

      const handleProcess = async () => {
        if (files.length === 0 || !xlsx) return;
        setIsProcessing(true);
        try {
          const parser = new AttendanceFileParser(xlsx);
          const parsedData = await parser.processFiles(files, settings);
          
          if (parsedData.restoredSettings) {
              setSettings(parsedData.restoredSettings);
          }
          setEmployees(parsedData.employees); 
          setFileMeta(parsedData.meta || {});
          setFiles([]);
          if (fileInputRef.current) fileInputRef.current.value = "";
          if (folderInputRef.current) folderInputRef.current.value = "";
          setView('dashboard');
        } catch (error) { alert(`エラー: ${error.message}`); } finally { setIsProcessing(false); }
      };

      const handleExport = () => {
        if (!xlsx) return;
        const wb = xlsx.utils.book_new();
        const limitDay = checkMode === 'day20' ? 20 : 31;
        
        const masterSchedule = Object.values(employees).find(e => e.schedule.length > 0)?.schedule || [];

        const metaRows = [
            ["Property", "Value"],
            ["ExportVersion", "11.17.21"],
            ["DirectorCount", employeeSummary.directorCount],
            ["ManagerCount", employeeSummary.managerCount],
            ["GeneralCount", employeeSummary.generalCount],
            ["FlexCount", employeeSummary.flexCount],
            ["MismatchCount", employeeSummary.mismatchEmployees.length],
            ["Settings_Managers", JSON.stringify(settings.managers)],
            ["Settings_Directors", JSON.stringify(settings.directors)], 
            ["Settings_Flex", JSON.stringify(settings.flexEmployees)],
            ["Settings_Mappings", JSON.stringify(settings.nameMappings)],
            ["Settings_CompensatoryBalances", JSON.stringify(settings.compensatoryLeaveBalances)],
            ["Mismatch_List", employeeSummary.mismatchEmployees.map(e=>e.employeeName).join(", ")],
            ["MissingReport_List", employeeSummary.missingReportEmployees.map(e=>e.employeeName).join(", ")]
        ];
        const wsMeta = xlsx.utils.aoa_to_sheet(metaRows);
        xlsx.utils.book_append_sheet(wb, wsMeta, "_Metadata");

        Object.values(employees).forEach(emp => {
          let currentNameNorm = normalizeName(emp.employeeName);
          let isManager = settings.managers.includes(currentNameNorm);
          let isDirector = settings.directors && settings.directors.includes(currentNameNorm);
          let isFlex = settings.flexEmployees.includes(currentNameNorm);
          
          if (settings.nameMappings) {
            const mapping = settings.nameMappings.find(m => normalizeName(m.nippo) === currentNameNorm || normalizeName(m.kintai) === currentNameNorm);
            if (mapping) {
              const kintaiName = normalizeName(mapping.kintai);
              if (settings.managers.includes(kintaiName) || settings.managers.includes(currentNameNorm)) isManager = true;
              if (settings.directors && (settings.directors.includes(kintaiName) || settings.directors.includes(currentNameNorm))) isDirector = true;
              if (settings.flexEmployees.includes(kintaiName) || settings.flexEmployees.includes(currentNameNorm)) isFlex = true;
            }
          }

          if (!isFlex && emp.serviceRecord && emp.serviceRecord.some(r => r.types && r.types.includes('フレックス'))) {
              isFlex = true;
          }

          const rows = [];
          
          const scheduleMap = {};
          emp.schedule.forEach(s => scheduleMap[s.day] = s);
          const serviceMap = {};
          emp.serviceRecord.forEach(s => serviceMap[s.day] = s);
          
          const results = [];
          for (let day = 1; day <= limitDay; day++) {
             const sch = scheduleMap[day] || {};
             const rep = emp.report.find(r => r.day === day) || {};
             const svc = serviceMap[day] || {};
             const nextDaySch = scheduleMap[day+1] || null;
             const nextDaySvc = serviceMap[day+1] || null;
             
             let derivedSch = { ...sch };
             let derivedSvc = { ...svc };
            
             if (!sch.weekday && masterSchedule.length > 0) {
                 const masterDay = masterSchedule.find(m => m.day === day);
                 if (masterDay) {
                     derivedSch.weekday = masterDay.weekday;
                     if (isDirector) derivedSch.status = masterDay.status; 
                 }
             }

             const hasSvcData = svc.status || svc.startTime || svc.endTime || (svc.regularTime > 0) || (svc.overtime > 0) || (svc.nightTime > 0) || (svc.timeAnnualLeave > 0);
             if (!hasSvcData) {
                 if (derivedSch.status || derivedSch.startTime || (derivedSch.regularTime > 0)) {
                     derivedSvc.startTime = derivedSch.startTime;
                     derivedSvc.endTime = derivedSch.endTime;
                     derivedSvc.regularTime = derivedSch.regularTime;
                     derivedSvc.overtime = derivedSch.overtime; 
                     derivedSvc.nightTime = derivedSch.nightTime; 
                     derivedSvc.timeAnnualLeave = derivedSch.timeAnnualLeave; 
                     derivedSvc.status = '勤務表から転記';
                 }
             }

             if (isDirector) {
                const hasSvc = Boolean(svc.status || svc.startTime);
                const hasRep = Boolean(rep.regularTime > 0 || rep.status);

                if (hasSvc) {
                    derivedSch.status = svc.status;
                    derivedSch.startTime = svc.startTime;
                    derivedSch.endTime = svc.endTime;
                    derivedSch.regularTime = svc.regularTime;
                    derivedSch.overtime = svc.overtime;
                    derivedSch.nightTime = svc.nightTime;
                } else if (!hasSvc && hasRep) {
                    derivedSvc.regularTime = rep.regularTime;
                    derivedSvc.status = '日報参照'; 
                    derivedSch.regularTime = rep.regularTime;
                    derivedSch.status = '日報参照';
                }
             }

             const check = checkDailyMismatch(derivedSch, rep, derivedSvc, isManager || isDirector, isFlex, nextDaySch, nextDaySvc);
             
             let schStatusStr = derivedSch.status || '';
             if (derivedSch.special) schStatusStr += (schStatusStr ? `, ${derivedSch.special}` : derivedSch.special);
             if (derivedSch.timeAnnualLeave > 0) schStatusStr += (schStatusStr ? ', 時間年休' : '時間年休');

             let svcStatusStr = derivedSvc.status || '';
             if (derivedSvc.types && derivedSvc.types.length > 0) {
                 const typesStr = derivedSvc.types.join(', ');
                 svcStatusStr += (svcStatusStr ? `, ${typesStr}` : typesStr);
             }

             let repStatusStr = rep.status || '';
             if (rep.startTime) repStatusStr = '記録あり ' + repStatusStr;
             if (rep.holidayWork > 0) repStatusStr += ' 休出';
             if (check.isNightWorkDay) repStatusStr += ' 夜業'; 
             if (rep.nightWorkVal) repStatusStr += ` (夜業${rep.nightWorkVal})`;

             results.push({
                 day, weekday: derivedSch.weekday || '', 
                 sch: derivedSch, rep, svc: derivedSvc, check,
                 schStatusStr, svcStatusStr, repStatusStr
             });
          }

          const isRegOK = results.every(r => Math.abs(r.check.diffRegular) < 0.01 || r.check.isSpecialCase);
          const isOverOK = results.every(r => Math.abs(r.check.diffOvertime) < 0.01);
          const isNightInputOK = results.every(r => Math.abs(r.check.diffNight) < 0.01 && !r.check.nightWorkCheckNG && !r.check.nightWorkMessage);
          
          let nightWorkDays = 0, hibanDays = 0, weekHolidayWorkCount = 0, compensatoryLeaveCount = 0;
          let saturdayHibanCount = 0, saturdayHibanMismatch = false;
          let divergenceCount = 0;
          
          let hasOvertimeRecord = false;
          let hasNightWorkRecord = false;
          let hasCompensatoryRecord = false;
          let hasLateNightWorkCandidate = false;
          let hasHalfDayLeave = false;

          let totalAnnualLeaveDays = 0;
          let totalHalfPaidLeaveDays = 0;
          let totalTimeAnnualLeave = 0;

          results.forEach(r => {
              const base = r.check.base;
              const hasSvcNightWork = (r.svc.types && r.svc.types.some(t => t.includes('夜業'))) || (r.svc.status && r.svc.status.includes('夜業'));
              if (hasSvcNightWork) nightWorkDays++;

              const isHiban = base.types ? base.types.some(t => t.includes('非番')) : (base.status && base.status.includes('非番'));
              if (isHiban) hibanDays++;
              if (base.types && base.types.some(t => t.includes('週休出') && t.includes('不算入'))) weekHolidayWorkCount++;
              if (base.types && base.types.some(t => t.includes('振休') || t.includes('振替休日'))) compensatoryLeaveCount++;
              else if (!base.types && base.status && (base.status.includes('振休') || base.status.includes('振替休日'))) compensatoryLeaveCount++;
              
              const isSat = r.weekday.includes('土');
              const isSvcHiban = r.svc.types ? r.svc.types.some(t => t.includes('非番')) : (r.svc.status && r.svc.status.includes('非番'));
              if (isSat && isSvcHiban) {
                  saturdayHibanCount++;
                  const mondayRow = results.find(rr => rr.day === r.day + 2); 
                  let hasMondayTarget = false;
                  if (mondayRow) {
                      const mSvc = mondayRow.svc;
                      hasMondayTarget = (mSvc.types && mSvc.types.some(t => (t.includes('週休出') && t.includes('不算入')) || t.includes('振休') || t.includes('振替休日')))
                                      || (!mSvc.types && mSvc.status && (mSvc.status.includes('振休') || mSvc.status.includes('振替休日')));
                  }
                  if (!hasMondayTarget) saturdayHibanMismatch = true;
              }
              if (r.svc.hasDivergence) divergenceCount++;

              if (
                  r.sch.overtime > 0 || r.svc.overtime > 0 || r.rep.overtime > 0 ||
                  (r.sch.status && r.sch.status.includes('残業')) ||
                  (r.svc.status && r.svc.status.includes('残業')) ||
                  (r.svc.types && r.svc.types.some(t => t.includes('残業'))) ||
                  (r.rep.status && r.rep.status.includes('残業')) ||
                  (r.sch.status && r.sch.status.includes('時間外')) ||
                  (r.svc.status && r.svc.status.includes('時間外')) ||
                  (r.svc.types && r.svc.types.some(t => t.includes('時間外'))) ||
                  (r.rep.status && r.rep.status.includes('時間外'))
              ) {
                  hasOvertimeRecord = true;
              }

              if (
                  (r.sch.status && (r.sch.status.includes('夜業') || r.sch.status.includes('非番'))) ||
                  (r.svc.status && (r.svc.status.includes('夜業') || r.svc.status.includes('非番'))) ||
                  (r.svc.types && r.svc.types.some(t => t.includes('夜業') || t.includes('非番'))) ||
                  (r.rep.status && (r.rep.status.includes('夜業') || r.rep.status.includes('非番'))) ||
                  (r.rep.nightWorkVal && parseFloat(r.rep.nightWorkVal) > 0) || 
                  r.check.isNightWorkDay 
              ) {
                  hasNightWorkRecord = true;
              }
              
              const svcEndTimeVal = parseSpecialTime(r.svc.endTime);
              if (!hasSvcNightWork && svcEndTimeVal > 22.0) {
                  hasLateNightWorkCandidate = true;
              }

              if (
                  (r.sch.status && (r.sch.status.includes('振休') || r.sch.status.includes('振替休日'))) ||
                  (r.svc.status && (r.svc.status.includes('振休') || r.svc.status.includes('振替休日'))) ||
                  (r.svc.types && r.svc.types.some(t => t.includes('振休') || t.includes('振替休日'))) ||
                  (r.rep.status && (r.rep.status.includes('振休') || r.rep.status.includes('振替休日')))
              ) {
                  hasCompensatoryRecord = true;
              }

              const svcTypes = r.svc.types || [];
              if (svcTypes.some(t => t === '年休' || t === '全日年休' || t === '有給休暇' || t === '有給')) {
                  totalAnnualLeaveDays += 1;
              }
              const halfLeaveCount = svcTypes.filter(t => t.includes('半休')).length;
              totalHalfPaidLeaveDays += halfLeaveCount * 0.5;
              totalTimeAnnualLeave += (r.svc.timeAnnualLeave || 0);

              if (halfLeaveCount > 0) hasHalfDayLeave = true;
          });
          
          if (saturdayHibanCount > 0) hasCompensatoryRecord = true;
          
          let nightWorkMismatch = false;
          if (!isManager && !isDirector && nightWorkDays !== hibanDays) nightWorkMismatch = true;
          const compensatoryLeaveMismatch = (saturdayHibanCount !== compensatoryLeaveCount);

          // 振休残情報の計算と出力
          const compInfo = calculateCompensatoryInfo(emp, settings);
          
          rows.push([`社員名: ${emp.employeeName}`, `ID: ${emp.employeeId}`]);
          rows.push([`対象年月: ${fileMeta.yearMonth || '不明'} (※自動検出)`]);
          rows.push(["【判定サマリー】"]);

          rows.push(["所定内一致", isRegOK ? "OK" : "NG"]);
          if (hasOvertimeRecord) {
              rows.push(["残業一致", isOverOK ? "OK" : "NG"]);
          } else {
              rows.push(["残業一致", "-"]);
          }

          if (hasNightWorkRecord) {
              rows.push(["夜業入力チェック", isNightInputOK ? "OK" : "NG"]);
              rows.push(["夜業/非番回数突合", !nightWorkMismatch ? "OK" : "NG", `(夜${nightWorkDays}/非${hibanDays})`]);
          } else {
              rows.push(["夜業入力チェック", "-"]);
              rows.push(["夜業/非番回数突合", "-"]);
          }

          // 振休残数管理の出力条件を変更
          if (compInfo.initialStock !== 0 || compInfo.earned !== 0 || compInfo.used !== 0 || compInfo.finalStock !== 0) {
             rows.push(["振休残数管理", 
               `期首:${compInfo.initialStock} + 発生:${compInfo.earned} - 消化:${compInfo.used} = 期末:${compInfo.finalStock}`,
               compInfo.warningUnused ? "【警告】未消化あり" : (compInfo.warningShortage ? "【警告】残数不足" : "OK")
             ]);
          } else {
             rows.push(["振休残数管理", "-"]);
          }

          if(divergenceCount > 0) {
              rows.push(["ログ乖離チェック", "NG", "(乖離有データあり)"]);
          } else {
              rows.push(["ログ乖離チェック", "OK"]);
          }

          if(emp.warnings && emp.warnings.length > 0) {
              rows.push(["重要警告", emp.warnings.join(", ")]);
          }
          rows.push([]); 

          rows.push([
            "日付", "曜日", 
            "【勤務表】ステータス(全)", "【勤務表】開始-終了", "【勤務表】所定内", "【勤務表】時間外", "【勤務表】深夜", "【勤務表】時間年休",
            "【服務簿】ステータス(全)", "【服務簿】開始-終了", "【服務簿】所定内", "【服務簿】時間外", "【服務簿】深夜", "【服務簿】時間年休", "【服務簿】乖離有無",
            "【日報】ステータス(全)", "【日報】開始", "【日報】所定内", "【日報】時間外", "【日報】深夜", "【日報】夜業値",
            "判定", "警告メッセージ"
          ]);

          results.forEach(r => {
             const row = [
               r.day, r.weekday,
               r.schStatusStr, (r.sch.startTime ? `${r.sch.startTime}-${r.sch.endTime}` : ''), formatSpecialTime(r.sch.regularTime), formatSpecialTime(r.sch.overtime), formatSpecialTime(r.sch.nightTime), formatSpecialTime(r.sch.timeAnnualLeave),
               r.svcStatusStr, (r.svc.startTime ? `${r.svc.startTime}-${r.svc.endTime}` : ''), formatSpecialTime(r.svc.regularTime), formatSpecialTime(r.svc.overtime), formatSpecialTime(r.svc.nightTime), formatSpecialTime(r.svc.timeAnnualLeave), r.svc.hasDivergence ? '乖離有' : '',
               r.repStatusStr, r.rep.startTime || '', formatSpecialTime(r.rep.regularTime), formatSpecialTime(r.rep.overtime), formatSpecialTime(r.rep.nightTime), r.rep.nightWorkVal || '',
               r.check.hasMismatch ? 'NG' : 'OK', r.check.warningMessage || r.check.nightWorkMessage || ''
             ];
             rows.push(row);
          });
          
          const ws = xlsx.utils.aoa_to_sheet(rows);
          let sheetName = emp.employeeName.slice(0, 25); 
          let uniqueName = sheetName;
          let counter = 1;
          while (wb.SheetNames.includes(uniqueName)) {
            uniqueName = `${sheetName}_${counter++}`;
          }
          xlsx.utils.book_append_sheet(wb, ws, uniqueName);
        });
        
        const fileName = fileMeta.yearMonth 
            ? `勤怠比較結果_${fileMeta.yearMonth}.xlsx` 
            : `勤怠比較結果_${new Date().toISOString().slice(0,7).replace(/-/g,'')}.xlsx`;

        xlsx.writeFile(wb, fileName);
      };

      const employeeList = useMemo(() => Object.values(employees), [employees]);
      const currentEmployee = employees[selectedId] || employeeList[0];

      const comparisonData = useMemo(() => {
        if (!currentEmployee) return [];
        const currentNameNorm = normalizeName(currentEmployee.employeeName);
        let isManager = settings.managers.includes(currentNameNorm);
        let isDirector = settings.directors && settings.directors.includes(currentNameNorm);
        let isFlex = settings.flexEmployees.includes(currentNameNorm);
        
        if (settings.nameMappings) {
          const mapping = settings.nameMappings.find(m => normalizeName(m.nippo) === currentNameNorm || normalizeName(m.kintai) === currentNameNorm);
          if (mapping) {
            const kintaiName = normalizeName(mapping.kintai);
            if (settings.managers.includes(kintaiName) || settings.managers.includes(currentNameNorm)) isManager = true;
            if (settings.directors && (settings.directors.includes(kintaiName) || settings.directors.includes(currentNameNorm))) isDirector = true;
            if (settings.flexEmployees.includes(kintaiName) || settings.flexEmployees.includes(currentNameNorm)) isFlex = true;
          }
        }

        if (!isFlex && currentEmployee.serviceRecord && currentEmployee.serviceRecord.some(r => r.types && r.types.includes('フレックス'))) {
            isFlex = true;
        }
        
        // --- カレンダーマスタの取得 (取締役などのスケジュールがない人用) ---
        const masterSchedule = Object.values(employees).find(e => e.schedule.length > 0)?.schedule || [];
        
        const limitDay = checkMode === 'day20' ? 20 : 31;
        const result = Array.from({ length: 31 }, (_, i) => i + 1)
          .filter(day => day <= limitDay)
          .map(day => {
            const sch = currentEmployee.schedule.find(r => r.day === day) || {};
            const rep = currentEmployee.report.find(r => r.day === day) || {};
            const svc = currentEmployee.serviceRecord.find(r => r.day === day) || {}; 
            const nextDaySch = currentEmployee.schedule.find(r => r.day === day + 1) || null;
            const nextDaySvc = currentEmployee.serviceRecord.find(r => r.day === day + 1) || null;
            
            // --- 取締役用データ補完 & カレンダー継承 ---
            let derivedSch = { ...sch };
            let derivedSvc = { ...svc };
            
            if (!sch.weekday && masterSchedule.length > 0) {
                const masterDay = masterSchedule.find(m => m.day === day);
                if (masterDay) {
                    derivedSch.weekday = masterDay.weekday;
                    if (isDirector) derivedSch.status = masterDay.status; 
                }
            }

            // --- 服務簿データがない場合、勤務表から転記 ---
            const hasSvcData = svc.status || svc.startTime || svc.endTime || (svc.regularTime > 0) || (svc.overtime > 0) || (svc.nightTime > 0) || (svc.timeAnnualLeave > 0);
            if (!hasSvcData) {
                // 勤務表に主要なデータがある場合のみコピー
                if (derivedSch.status || derivedSch.startTime || (derivedSch.regularTime > 0)) {
                    derivedSvc.startTime = derivedSch.startTime;
                    derivedSvc.endTime = derivedSch.endTime;
                    derivedSvc.regularTime = derivedSch.regularTime;
                    derivedSvc.overtime = derivedSch.overtime; 
                    derivedSvc.nightTime = derivedSch.nightTime; 
                    derivedSvc.timeAnnualLeave = derivedSch.timeAnnualLeave; 
                    derivedSvc.status = '勤務表から転記';
                }
            }

            if (isDirector) {
                const hasSvc = Boolean(svc.status || svc.startTime);
                const hasRep = Boolean(rep.regularTime > 0 || rep.status);

                if (hasSvc) {
                    derivedSch.status = svc.status;
                    derivedSch.startTime = svc.startTime;
                    derivedSch.endTime = svc.endTime;
                    derivedSch.regularTime = svc.regularTime;
                    derivedSch.overtime = svc.overtime;
                    derivedSch.nightTime = svc.nightTime;
                } else if (!hasSvc && hasRep) {
                    derivedSvc.regularTime = rep.regularTime;
                    derivedSvc.status = '日報参照'; 
                    derivedSch.regularTime = rep.regularTime;
                    derivedSch.status = '日報参照';
                }
            }

            const check = checkDailyMismatch(derivedSch, rep, derivedSvc, isManager || isDirector, isFlex, nextDaySch, nextDaySvc);
            
            let rowColor = '';
            const weekday = derivedSch.weekday || '';
            const status = derivedSch.status || '';

            if (status.includes('加休')) { rowColor = 'bg-red-50'; } 
            else if (weekday.includes('日')) { rowColor = 'bg-red-50'; } 
            else if (weekday.includes('土')) { rowColor = 'bg-blue-50'; }

            const hasNightWork = check.isNightWorkDay; 

            // 土曜非番判定用
            const isSat = weekday.includes('土');
            const isSvcHiban = derivedSvc.types ? derivedSvc.types.some(t => t.includes('非番')) : (derivedSvc.status && derivedSvc.status.includes('非番'));
            
            return { 
              day, weekday, rowColor,
              sch: derivedSch, rep, svc: derivedSvc, ...check, // 補完後のデータを使用
              hasData: derivedSch.status || rep.status || derivedSvc.status || derivedSch.overtime > 0 || rep.overtime > 0 || derivedSvc.startTime || derivedSch.regularTime > 0 || rep.regularTime > 0, 
              hasHolidayWork: rep.holidayWork > 0,
              hasNightWork,
              isSaturdayHibanNG: false,
              check // これを追加
            };
          }).filter(d => d.hasData);
        
        // --- 残業時間合計計算と45時間超過判定 ---
        const totalRegularSvc = result.reduce((acc, r) => acc + (r.svc.regularTime || 0), 0);
        const totalRegularRep = result.reduce((acc, r) => acc + (r.rep.regularTime || 0), 0);
        const totalOvertimeSvc = result.reduce((acc, r) => acc + (r.svc.overtime || 0), 0);
        const totalOvertimeRep = result.reduce((acc, r) => acc + (r.rep.overtime || 0), 0);
        
        // 合計での差異チェック (diffRegular, diffOvertime の合計が0に近いかで判定)
        // これにより、日々のズレが相殺されていればOKとなる（または特例処理後の差異合計を見る）
        const totalDiffRegular = result.reduce((acc, r) => acc + r.diffRegular, 0);
        const totalDiffOvertime = result.reduce((acc, r) => acc + r.diffOvertime, 0);
        
        const isRegularTotalMatch = Math.abs(totalDiffRegular) < 0.01;
        const isOvertimeTotalMatch = Math.abs(totalDiffOvertime) < 0.01;

        const totalOvertimeSch = result.reduce((acc, r) => acc + (r.sch.overtime || 0), 0);
        const isOvertimeLimitExceeded = totalOvertimeSch > 45.0 || totalOvertimeSvc > 45.0 || totalOvertimeRep > 45.0;

        let nightWorkDays = 0;
        let hibanDays = 0;
        let nightWorkMismatch = false;
        let weekHolidayWorkCount = 0;
        let compensatoryLeaveCount = 0;
        let saturdayHibanCount = 0;
        let saturdayHibanMismatch = false;
        let divergenceCount = 0; // 追加
        
        // 表示制御用フラグ
        let hasOvertimeRecord = false;
        let hasNightWorkRecord = false;
        let hasCompensatoryRecord = false;
        let hasLateNightWorkCandidate = false; // 深夜残業対象候補
        let hasHalfDayLeave = false; // 半休有無 (Ver.11.17.9)

        // 休暇集計用の変数
        let totalAnnualLeaveDays = 0;
        let totalHalfPaidLeaveDays = 0;
        let totalTimeAnnualLeave = 0;

        result.forEach(r => {
            const base = r.check.base;
            // 修正箇所：服務簿の種別(types)またはステータス(status)に「夜業」が含まれている場合にカウント
            const hasSvcNightWork = (r.svc.types && r.svc.types.some(t => t.includes('夜業'))) || (r.svc.status && r.svc.status.includes('夜業'));
            if (hasSvcNightWork) nightWorkDays++;

            const isHiban = base.types ? base.types.some(t => t.includes('非番')) : (base.status && base.status.includes('非番'));
            if (isHiban) hibanDays++;
            if (base.types && base.types.some(t => t.includes('週休出') && t.includes('不算入'))) weekHolidayWorkCount++;
            if (base.types && base.types.some(t => t.includes('振休') || t.includes('振替休日'))) compensatoryLeaveCount++;
            else if (!base.types && base.status && (base.status.includes('振休') || base.status.includes('振替休日'))) compensatoryLeaveCount++;
            
            const isSat = r.weekday.includes('土');
            const isSvcHiban = r.svc.types ? r.svc.types.some(t => t.includes('非番')) : (r.svc.status && r.svc.status.includes('非番'));
            if (isSat && isSvcHiban) {
                saturdayHibanCount++;
                const mondayRow = result.find(rr => rr.day === r.day + 2); // 修正箇所: result -> results
                let hasMondayTarget = false;
                if (mondayRow) {
                    const mSvc = mondayRow.svc;
                    hasMondayTarget = (mSvc.types && mSvc.types.some(t => (t.includes('週休出') && t.includes('不算入')) || t.includes('振休') || t.includes('振替休日')))
                                      || (!mSvc.types && mSvc.status && (mSvc.status.includes('振休') || mSvc.status.includes('振替休日')));
                }
                if (!hasMondayTarget) saturdayHibanMismatch = true;
            }
            // 乖離カウント
            if (r.svc.hasDivergence) divergenceCount++;

            // 1. 残業関連
            if (
                r.sch.overtime > 0 || r.svc.overtime > 0 || r.rep.overtime > 0 ||
                (r.sch.status && r.sch.status.includes('残業')) ||
                (r.svc.status && r.svc.status.includes('残業')) ||
                (r.svc.types && r.svc.types.some(t => t.includes('残業'))) ||
                (r.rep.status && r.rep.status.includes('残業')) ||
                (r.sch.status && r.sch.status.includes('時間外')) ||
                (r.svc.status && r.svc.status.includes('時間外')) ||
                (r.svc.types && r.svc.types.some(t => t.includes('時間外'))) ||
                (r.rep.status && r.rep.status.includes('時間外'))
            ) {
                hasOvertimeRecord = true;
            }

            // 2. 夜業・非番関連
            // 修正 (Ver.11.17.10で修正した箇所)
            if (
                (r.sch.status && (r.sch.status.includes('夜業') || r.sch.status.includes('非番'))) ||
                (r.svc.status && (r.svc.status.includes('夜業') || r.svc.status.includes('非番'))) ||
                (r.svc.types && r.svc.types.some(t => t.includes('夜業') || t.includes('非番'))) ||
                (r.rep.status && (r.rep.status.includes('夜業') || r.rep.status.includes('非番'))) ||
                (r.rep.nightWorkVal && parseFloat(r.rep.nightWorkVal) > 0) || 
                r.check.isNightWorkDay // 日報深夜時間が7.0hの場合
            ) {
                hasNightWorkRecord = true;
            }
            
            // 深夜残業チェック対象（夜業以外かつ22時以降終了）があるか
            const svcEndTimeVal = parseSpecialTime(r.svc.endTime);
            if (!hasSvcNightWork && svcEndTimeVal > 22.0) {
                hasLateNightWorkCandidate = true;
            }

            // 3. 振休関連
            if (
                (r.sch.status && (r.sch.status.includes('振休') || r.sch.status.includes('振替休日'))) ||
                (r.svc.status && (r.svc.status.includes('振休') || r.svc.status.includes('振替休日'))) ||
                (r.svc.types && r.svc.types.some(t => t.includes('振休') || t.includes('振替休日'))) ||
                (r.rep.status && (r.rep.status.includes('振休') || r.rep.status.includes('振替休日')))
            ) {
                hasCompensatoryRecord = true;
            }

            // 休暇集計
            const svcTypes = r.svc.types || [];
            if (svcTypes.some(t => t === '年休' || t === '全日年休' || t === '有給休暇' || t === '有給')) {
                totalAnnualLeaveDays += 1;
            }
            const halfLeaveCount = svcTypes.filter(t => t.includes('半休')).length;
            totalHalfPaidLeaveDays += halfLeaveCount * 0.5;
            totalTimeAnnualLeave += (r.svc.timeAnnualLeave || 0);

            if (halfLeaveCount > 0) hasHalfDayLeave = true;
        });
        
        if (saturdayHibanCount > 0) hasCompensatoryRecord = true;
        
        nightWorkMismatch = false;
        if (!isManager && !isDirector && nightWorkDays !== hibanDays) nightWorkMismatch = true;
        const compensatoryLeaveMismatch = (saturdayHibanCount !== compensatoryLeaveCount); // 週休出ではなく土曜非番と比較
        
        // 振休残計算
        const compInfo = calculateCompensatoryInfo(currentEmployee, settings);

        return { 
            rows: result, 
            summary: { 
                nightWorkDays, hibanDays, nightWorkMismatch, weekHolidayWorkCount, compensatoryLeaveCount, compensatoryLeaveMismatch, saturdayHibanCount, saturdayHibanMismatch,
                isOvertimeLimitExceeded, totalOvertimeSch, totalOvertimeSvc, totalOvertimeRep, divergenceCount, // 追加
                hasOvertimeRecord, hasNightWorkRecord, hasCompensatoryRecord, hasLateNightWorkCandidate, // 追加
                totalRegularSvc, totalRegularRep, 
                isRegularTotalMatch, isOvertimeTotalMatch, // 追加
                totalAnnualLeaveDays, totalHalfPaidLeaveDays, totalTimeAnnualLeave, // 休暇集計追加
                hasHalfDayLeave, // 半休チェック表示用
                compInfo // 振休残情報
            }, 
            isManager, isDirector, isFlex 
        };
      }, [currentEmployee, settings, checkMode, employees]); 

      const selectEmployeeByKey = (emp) => setSelectedId(Object.keys(employees).find(k => employees[k] === emp));

      // --- 追加: 全NG項目収集ロジック ---
      const collectAllNgItems = () => {
          const d = comparisonData;
          const allErrors = [];

          // 1. 所定内
          const regErrors = d.rows.filter(r => Math.abs(r.diffRegular) > 0.01 && !r.isSpecialCase);
          if (regErrors.length > 0) {
              allErrors.push({
                  category: '所定内不一致',
                  items: regErrors.map(r => ({ date: `${r.day}日(${r.weekday})`, message: `差分: ${formatSpecialTime(r.diffRegular)}h (勤務表:${formatSpecialTime(r.sch.regularTime)} vs 日報:${formatSpecialTime(r.rep.regularTime)}) ${d.warningMessage || ''}` }))
              });
          }

          // 2. 残業
          const overErrors = d.rows.filter(r => d.isFlex ? r.sch.overtime > 0 : Math.abs(r.diffOvertime) > 0.01);
          if (overErrors.length > 0) {
              allErrors.push({
                  category: '残業不一致',
                  items: overErrors.map(r => ({ 
                      date: `${r.day}日(${r.weekday})`, 
                      message: d.isFlex ? `FLEX残業NG: ${formatSpecialTime(r.sch.overtime)}h` : `差分: ${formatSpecialTime(r.diffOvertime)}h (勤務表:${formatSpecialTime(r.sch.overtime)} vs 日報:${formatSpecialTime(r.rep.overtime)})`
                  }))
              });
          }

          // 3. 残業時間超過(45h)
          if (d.summary.isOvertimeLimitExceeded) {
              const items = [];
              if (d.summary.totalOvertimeSch > 45.0) items.push({ date: '-', message: `勤務表の残業合計: ${formatSpecialTime(d.summary.totalOvertimeSch)}h (45h超過)` });
              if (d.summary.totalOvertimeSvc > 45.0) items.push({ date: '-', message: `服務簿の残業合計: ${formatSpecialTime(d.summary.totalOvertimeSvc)}h (45h超過)` });
              if (d.summary.totalOvertimeRep > 45.0) items.push({ date: '-', message: `日報の残業合計: ${formatSpecialTime(d.summary.totalOvertimeRep)}h (45h超過)` });
              allErrors.push({ category: '残業時間超過(45h)', items });
          }

          // 4. 夜業入力
          const nightErrors = d.rows.filter(r => Math.abs(r.diffNight) > 0.01 || r.nightWorkCheckNG || r.nightWorkMessage);
          if (nightErrors.length > 0) {
              allErrors.push({
                  category: '夜業入力不備',
                  items: nightErrors.map(r => ({
                      date: `${r.day}日(${r.weekday})`,
                      message: [
                          Math.abs(r.diffNight) > 0.01 ? `深夜時間差分: ${formatSpecialTime(r.diffNight)}h` : '',
                          r.nightWorkCheckNG ? '日報夜業チェックNG' : '',
                          r.nightWorkMessage
                      ].filter(Boolean).join(', ')
                  }))
              });
          }

          // 5. 翌日非番 / 土曜非番 / 管理職非番
          const nextDayErrors = [];
          if (d.isManager || d.isDirector) {
              if (d.summary.hibanDays > 0) {
                  nextDayErrors.push({ date: '-', message: '管理職・取締役は非番を取得できません' });
              }
          } else {
              d.rows.filter(r => r.nextDayCheckOK === false).forEach(r => {
                  const nextDayRow = d.rows.find(row => row.day === r.day + 1);
                  const dateStr = nextDayRow ? `${nextDayRow.day}日(${nextDayRow.weekday})` : `${r.day + 1}日`;
                  nextDayErrors.push({ date: dateStr, message: '翌日が非番になっていません(夜業明け)' });
              });
              d.rows.filter(r => r.isSaturdayHibanNG).forEach(r => {
                  nextDayErrors.push({ date: `${r.day}日(${r.weekday})`, message: '土曜非番に対する月曜振休がありません' });
              });
          }
          if (nextDayErrors.length > 0) {
              allErrors.push({ category: '非番関連不備', items: nextDayErrors });
          }

          // 6. 夜業突合 (管理職以外)
          if (d.summary.nightWorkMismatch) {
              allErrors.push({
                  category: '夜業/非番回数不一致',
                  items: [
                      { date: '-', message: `夜業回数: ${d.summary.nightWorkDays}回` },
                      { date: '-', message: `非番回数: ${d.summary.hibanDays}回` },
                      { date: '参考', message: '管理職以外は回数が一致する必要があります' }
                  ]
              });
          }

          // 7. 振休突合
          // if (d.summary.compensatoryLeaveMismatch) { ... } // 削除（振休突合チェックは不要）
          
          // 8. 深夜残業 (新規追加)
          const lateNightErrors = d.rows.filter(r => r.lateNightOvertimeNG);
          if (lateNightErrors.length > 0) {
              allErrors.push({
                  category: '深夜残業不一致',
                  items: lateNightErrors.map(r => ({
                      date: `${r.day}日(${r.weekday})`,
                      message: `深夜時間不一致 (服務簿:${formatSpecialTime(r.svc.nightTime)}h vs 日報:${formatSpecialTime(r.rep.nightTime)}h) ※夜業以外で22時以降終了`
                  }))
              });
          }
          
          // 9. ログ乖離
          const divergenceErrors = d.rows.filter(r => r.svc.hasDivergence);
          if (divergenceErrors.length > 0) {
              allErrors.push({
                  category: 'ログ乖離あり',
                  items: divergenceErrors.map(r => ({
                      date: `${r.day}日(${r.weekday})`,
                      message: '乖離有（申請要）'
                  }))
              });
          }

          // 10. 半休時刻チェック (Ver.11.17.9)
          const halfLeaveErrors = d.rows.filter(r => r.warningMessage && r.warningMessage.includes('半休'));
          if (halfLeaveErrors.length > 0) {
              allErrors.push({
                  category: '半休時刻チェック',
                  items: halfLeaveErrors.map(r => ({
                      date: `${r.day}日(${r.weekday})`,
                      message: r.warningMessage
                  }))
              });
          }

          // 11. 重要警告
          if (currentEmployee.warnings && currentEmployee.warnings.length > 0) {
              allErrors.push({
                  category: '重要警告',
                  items: currentEmployee.warnings.map(w => ({ date: '-', message: w }))
              });
          }
          
          // 12. 振休残数警告
          if (d.summary.compInfo.warningUnused) {
              allErrors.push({ category: '振休残数', items: [{ date: '-', message: '前月残が未消化です' }] });
          }
          if (d.summary.compInfo.warningShortage) {
              allErrors.push({ category: '振休残数', items: [{ date: '-', message: '振休残数が不足しています' }] });
          }

          return allErrors;
      };

      // タブ表示用の月取得
      const targetMonthStr = fileMeta.yearMonth ? `${parseInt(fileMeta.yearMonth.slice(4))}月` : '';

      return (
        <div className="h-full w-full bg-slate-50 text-slate-900 p-4 md:p-6 flex flex-col overflow-hidden">
          <header className="shrink-0 max-w-7xl mx-auto w-full mb-4 flex flex-col md:flex-row items-center justify-between gap-4">
            <div className="flex items-center gap-3">
              <div className="bg-indigo-600 p-2 rounded-xl text-white shadow-lg"><Zap className="w-6 h-6" /></div>
              <div><h1 className="text-xl font-bold text-slate-800">勤怠データ照合ツール (Ver.11.17.21)</h1><p className="text-xs text-slate-500 font-medium">旧姓統合・フレックス数表示対応・Excel復元機能・取締役対応</p></div>
            </div>
            <div className="flex items-center gap-2">
              <button onClick={() => setShowHelp(true)} className="flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-bold bg-white text-emerald-600 border border-emerald-200 hover:bg-emerald-50 transition-colors"><HelpCircle className="w-4 h-4" /> ヘルプ</button>
              <button onClick={() => setShowSettings(true)} className="flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold bg-white text-slate-600 border hover:bg-slate-50 transition-colors"><Settings className="w-4 h-4" /> 設定</button>
              
              {/* --- 結果保存ボタン --- */}
              <button onClick={handleExport} disabled={employeeList.length === 0} className="flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-bold bg-white text-indigo-600 border border-indigo-200 hover:bg-indigo-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                <Download className="w-4 h-4" /> 結果保存
              </button>

              <div className="flex bg-white p-1 rounded-xl border border-slate-200 shadow-sm">
                <button onClick={() => setView('input')} className={`px-4 py-2 rounded-lg text-sm font-bold transition-all ${view === 'input' ? 'bg-indigo-600 text-white shadow-md' : 'text-slate-500 hover:bg-slate-50'}`}>ファイル登録</button>
                <button onClick={() => setView('dashboard')} disabled={employeeList.length === 0} className={`px-4 py-2 rounded-lg text-sm font-bold transition-all ${view === 'dashboard' ? 'bg-indigo-600 text-white shadow-md' : 'text-slate-500 hover:bg-slate-50 disabled:opacity-30'}`}>比較ボード</button>
              </div>
            </div>
          </header>
          
          <main className="flex-1 w-full max-w-7xl mx-auto overflow-hidden flex flex-col min-h-0">
            {view === 'input' ? (
              <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 overflow-y-auto h-full content-start">
                {/* ... (File upload UI remains same) ... */}
                <div className="lg:col-span-2 space-y-6">
                  <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-200 relative overflow-hidden">
                    <div className="flex items-center gap-2 mb-4"><div className="p-2 bg-indigo-50 text-indigo-600 rounded-lg"><FileSpreadsheet className="w-5 h-5" /></div><h2 className="font-bold">ファイルアップロード</h2></div>
                    <div className="flex gap-4">
                      <div className={`flex-1 border-2 border-dashed border-slate-200 rounded-2xl p-8 text-center transition-all cursor-pointer group ${!xlsx ? 'opacity-50 pointer-events-none' : 'hover:border-indigo-400 hover:bg-indigo-50/50'}`} onClick={() => fileInputRef.current?.click()}>
                        <input type="file" ref={fileInputRef} className="hidden" multiple accept=".xls, .xlsx, .csv" onChange={onFileChange} />
                        <Upload className="w-8 h-8 mx-auto mb-2 text-slate-300 group-hover:text-indigo-500 transition-colors" />
                        <p className="text-sm font-bold text-slate-600">ファイルを選択</p>
                      </div>
                      <div className={`flex-1 border-2 border-dashed border-slate-200 rounded-2xl p-8 text-center transition-all cursor-pointer group ${!xlsx ? 'opacity-50 pointer-events-none' : 'hover:border-indigo-400 hover:bg-indigo-50/50'}`} onClick={() => folderInputRef.current?.click()}>
                        <input type="file" ref={folderInputRef} className="hidden" multiple onChange={onFileChange} />
                        <FolderInput className="w-8 h-8 mx-auto mb-2 text-slate-300 group-hover:text-indigo-500 transition-colors" />
                        <p className="text-sm font-bold text-slate-600">フォルダを選択</p>
                      </div>
                    </div>
                    {files.length > 0 && <div className="mt-4 space-y-2 max-h-40 overflow-y-auto">{files.map((file, idx) => (<div key={idx} className="flex items-center justify-between p-3 bg-slate-50 rounded-xl border border-slate-100 text-sm"><span className="font-bold text-slate-700 truncate flex items-center gap-2"><FileText className="w-4 h-4 text-indigo-500" />{file.name}</span><button onClick={() => removeFile(idx)} className="text-slate-400 hover:text-rose-500 p-2"><X className="w-4 h-4" /></button></div>))}</div>}
                  </div>
                  <button onClick={handleProcess} disabled={isProcessing || files.length === 0} className="w-full py-4 bg-indigo-600 hover:bg-indigo-700 disabled:bg-slate-300 text-white font-black rounded-2xl transition-all flex items-center justify-center gap-3 shadow-xl shadow-indigo-200 active:scale-95">{isProcessing ? <><Loader2 className="w-6 h-6 animate-spin" />解析中...</> : <><Table className="w-6 h-6" />解析を実行</>}</button>
                </div>
                <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-200 h-fit"><h3 className="font-bold mb-4 flex items-center gap-2 border-b pb-4"><Users className="w-5 h-5 text-indigo-600" />解析済みデータ ({employeeList.length})</h3>
                  <div className="space-y-2 max-h-[600px] overflow-y-auto">{employeeList.map((emp, i) => (<div key={i} className="p-3 border rounded-xl bg-slate-50/50 flex items-center justify-between"><div><div className="text-[9px] font-mono text-slate-400">ID: {emp.employeeId}</div><div className="text-sm font-bold text-slate-700">{emp.employeeName}</div></div></div>))}</div>
                </div>
              </div>
            ) : (
              <div className="flex flex-col gap-4 h-full overflow-hidden">
                <div className="shrink-0 bg-white p-4 rounded-2xl border border-slate-200 shadow-sm flex flex-col md:flex-row gap-6 items-start">
                  <div className="flex gap-4 p-2">
                    <div className="text-center px-4 border-r"><div className="text-xs text-slate-400 font-bold mb-1">取締役</div><div className="text-2xl font-black text-slate-700">{employeeSummary.directorCount} <span className="text-sm font-normal text-slate-400">名</span></div></div>
                    <div className="text-center px-4 border-r"><div className="text-xs text-slate-400 font-bold mb-1">管理職</div><div className="text-2xl font-black text-slate-700">{employeeSummary.managerCount} <span className="text-sm font-normal text-slate-400">名</span></div></div>
                    <div className="text-center px-4 border-r"><div className="text-xs text-slate-400 font-bold mb-1">一般社員</div><div className="text-2xl font-black text-slate-700">{employeeSummary.generalCount} <span className="text-sm font-normal text-slate-400">名</span></div></div>
                    <div className="text-center px-4"><div className="text-xs text-slate-400 font-bold mb-1">フレックス</div><div className="text-2xl font-black text-slate-700">{employeeSummary.flexCount} <span className="text-sm font-normal text-slate-400">名</span></div></div>
                  </div>
                  <div className="flex-1 w-full space-y-2">
                    {/* 不整合ありアコーディオン */}
                    <div className="w-full">
                      <div className={`flex items-center justify-between p-3 rounded-xl cursor-pointer transition-colors ${employeeSummary.mismatchEmployees.length > 0 ? 'bg-rose-50 hover:bg-rose-100 text-rose-800' : 'bg-emerald-50 text-emerald-800'}`} onClick={() => setMismatchListOpen(!mismatchListOpen)}>
                        <div className="flex items-center gap-2 font-bold">{employeeSummary.mismatchEmployees.length > 0 ? <AlertTriangle className="w-5 h-5" /> : <CheckCircle2 className="w-5 h-5" />}不整合あり: {employeeSummary.mismatchEmployees.length} 名 {checkMode === 'day20' && <span className="text-[10px] bg-amber-100 text-amber-700 px-2 py-0.5 rounded-full ml-2">20日〆</span>}</div>
                        <ChevronRight className={`w-5 h-5 transition-transform ${mismatchListOpen ? 'rotate-90' : ''}`} />
                      </div>
                      {mismatchListOpen && employeeSummary.mismatchEmployees.length > 0 && <div className="mt-2 p-2 bg-white border border-rose-100 rounded-xl shadow-sm grid grid-cols-2 md:grid-cols-4 gap-2 max-h-32 overflow-y-auto">{employeeSummary.mismatchEmployees.map(emp => (<button key={emp.employeeId} onClick={() => selectEmployeeByKey(emp)} className="text-left px-3 py-2 text-sm font-bold text-rose-600 hover:bg-rose-50 rounded-lg truncate flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-rose-500 inline-block flex-shrink-0"></span>{emp.employeeName}{emp.warnings && emp.warnings.includes('H列不整合') && <span className="text-[9px] bg-black text-white px-1 rounded">H列</span>}</button>))}</div>}
                    </div>
                    {/* 日報未提出アコーディオン */}
                    {employeeSummary.missingReportEmployees.length > 0 && (
                        <div className="w-full">
                          <div className="flex items-center justify-between p-3 rounded-xl cursor-pointer transition-colors bg-amber-50 hover:bg-amber-100 text-amber-800" onClick={() => setMissingListOpen(!missingListOpen)}>
                            <div className="flex items-center gap-2 font-bold"><FileWarning className="w-5 h-5" />日報未提出: {employeeSummary.missingReportEmployees.length} 名</div>
                            <ChevronRight className={`w-5 h-5 transition-transform ${missingListOpen ? 'rotate-90' : ''}`} />
                          </div>
                          {missingListOpen && (
                            <div className="mt-2 p-2 bg-white border border-amber-100 rounded-xl shadow-sm grid grid-cols-2 md:grid-cols-4 gap-2 max-h-32 overflow-y-auto">
                              {employeeSummary.missingReportEmployees.map(emp => (
                                <button key={emp.employeeId} onClick={() => selectEmployeeByKey(emp)} className="text-left px-3 py-2 text-sm font-bold text-amber-700 hover:bg-amber-50 rounded-lg truncate flex items-center gap-1">
                                  <span className="w-2 h-2 rounded-full bg-amber-500 inline-block flex-shrink-0"></span>{emp.employeeName}
                                </button>
                              ))}
                            </div>
                          )}
                        </div>
                    )}
                  </div>
                </div>
                
                <div className="shrink-0 flex justify-center bg-white p-2 rounded-xl shadow-sm border border-slate-200">
                  <button onClick={() => setCheckMode('full')} className={`flex-1 px-4 py-2 rounded-lg text-sm font-bold transition-all ${checkMode === 'full' ? 'bg-indigo-600 text-white shadow-md' : 'text-slate-500 hover:bg-slate-50'}`}>通常 ({targetMonthStr ? targetMonthStr + '末' : '月末'}まで)</button>
                  <button onClick={() => setCheckMode('day20')} className={`flex-1 px-4 py-2 rounded-lg text-sm font-bold transition-all flex items-center justify-center gap-2 ${checkMode === 'day20' ? 'bg-amber-500 text-white shadow-md' : 'text-slate-500 hover:bg-slate-50'}`}><CalendarCheck className="w-4 h-4" /> {targetMonthStr ? targetMonthStr + '20日' : '20日'}締め</button>
                </div>

                <div className="flex-1 flex gap-6 overflow-hidden min-h-0">
                  <aside className="w-64 shrink-0 overflow-y-auto pr-2 pb-4">
                    <h3 className="text-[10px] font-black text-slate-400 px-3 py-1 uppercase tracking-widest flex justify-between items-center sticky top-0 bg-slate-50 z-10">
                      Employee List
                      {checkMode === 'day20' && <span className="text-[9px] bg-amber-500 text-white px-1 rounded">20日〆</span>}
                    </h3>
                    <div className="space-y-2">
                    {employeeList.map((emp) => {
                      const key = Object.keys(employees).find(k => employees[k] === emp);
                      const isMismatch = employeeSummary.mismatchEmployees.includes(emp);
                      const isMissingReport = employeeSummary.missingReportEmployees.includes(emp);
                      const normName = normalizeName(emp.employeeName);
                      let isManager = settings.managers.includes(normName);
                      let isDirector = settings.directors && settings.directors.includes(normName);
                      let isFlex = settings.flexEmployees.includes(normName);
                      
                      if (settings.nameMappings) {
                        const m = settings.nameMappings.find(map => normalizeName(map.nippo) === normName || normalizeName(map.kintai) === normName);
                        if(m) {
                           const kn = normalizeName(m.kintai);
                           const nn = normalizeName(m.nippo);
                           if(settings.managers.includes(kn) || settings.managers.includes(nn)) isManager=true;
                           if(settings.directors && (settings.directors.includes(kn) || settings.directors.includes(nn))) isDirector=true;
                           if(settings.flexEmployees.includes(kn) || settings.flexEmployees.includes(nn)) isFlex=true;
                        }
                      }

                      if (!isFlex && emp.serviceRecord && emp.serviceRecord.some(r => r.types && r.types.includes('フレックス'))) {
                          isFlex = true;
                      }

                      return (<button key={key} onClick={() => setSelectedId(key)} className={`w-full p-3 rounded-2xl text-left transition-all flex items-center justify-between border ${selectedId === key ? 'bg-indigo-600 text-white border-indigo-600 shadow-lg scale-105 z-10' : 'bg-white border-slate-200 hover:bg-slate-50'}`}><div className="truncate flex-1"><div className={`text-[9px] font-mono ${selectedId === key ? 'text-indigo-200' : 'text-slate-400'}`}>{emp.employeeId}</div><div className="font-bold truncate text-sm flex items-center gap-1">{emp.employeeName}{isManager && <span className="text-[9px] bg-purple-100 text-purple-700 px-1 rounded">管</span>}{isDirector && <span className="text-[9px] bg-yellow-100 text-yellow-700 px-1 rounded">取</span>}{isFlex && <span className="text-[9px] bg-orange-100 text-orange-700 px-1 rounded">F</span>}{isMismatch && <span className="w-2 h-2 rounded-full bg-rose-500"></span>}{isMissingReport && <span className="w-2 h-2 rounded-full bg-amber-500 ml-1"></span>}</div></div><ChevronRight className={`w-4 h-4 shrink-0 ${selectedId === key ? 'opacity-100' : 'opacity-20'}`} /></button>);
                    })}
                    </div>
                  </aside>
                  <div className="flex-1 flex flex-col overflow-hidden min-h-0">
                    {!currentEmployee ? (
                      <div className="bg-white h-full rounded-3xl border-2 border-dashed border-slate-200 flex flex-col items-center justify-center text-slate-400"><p className="font-bold text-sm">社員を選択してください</p></div>
                    ) : (
                      <>
                        <div className="shrink-0 mb-4">
                           <div className="bg-white p-3 rounded-xl border border-slate-200 shadow-sm grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-2 text-xs">
                             
                             {/* 所定内 */}
                             <div 
                               className={`p-2 rounded font-bold text-center border ${comparisonData.summary.isRegularTotalMatch ? 'bg-emerald-50 text-emerald-700 border-emerald-100' : 'bg-rose-50 text-rose-700 border-rose-100 cursor-pointer'}`}
                               onClick={() => {
                                 if (comparisonData.summary.isRegularTotalMatch) return;
                                 const allNg = collectAllNgItems();
                                 if (allNg.length === 0) return;
                                 setNgDetailData({
                                   title: '所定内不一致 (詳細)', 
                                   items: comparisonData.rows
                                     .filter(d => Math.abs(d.diffRegular) > 0.01 && !d.isSpecialCase)
                                     .map(d => ({
                                       date: `${d.day}日(${d.weekday})`,
                                       message: `差分: ${formatSpecialTime(d.diffRegular)}h (勤務表:${formatSpecialTime(d.sch.regularTime)} vs 日報:${formatSpecialTime(d.rep.regularTime)}) ${d.warningMessage || ''}`
                                     })),
                                   allItems: allNg,
                                   employeeName: currentEmployee.employeeName 
                                 });
                               }}
                             >
                               所定内: {comparisonData.summary.isRegularTotalMatch ? 'OK' : 'NG'}
                             </div>

                             {/* 残業 */}
                             {comparisonData.summary.hasOvertimeRecord && (
                               <div 
                                 className={`p-2 rounded font-bold text-center border ${comparisonData.summary.isOvertimeTotalMatch && !comparisonData.summary.isOvertimeLimitExceeded ? 'bg-emerald-50 text-emerald-700 border-emerald-100' : 'bg-rose-50 text-rose-700 border-rose-100 cursor-pointer'}`}
                                 onClick={() => {
                                   if (comparisonData.summary.isOvertimeTotalMatch && !comparisonData.summary.isOvertimeLimitExceeded) return;
                                   const allNg = collectAllNgItems();
                                   if (allNg.length === 0) return;
                                   
                                   // このボタン用のアイテムのみ生成
                                   const items = [];
                                   
                                   // 残業不一致
                                   comparisonData.rows
                                     .filter(d => comparisonData.isFlex ? d.sch.overtime > 0 : Math.abs(d.diffOvertime) > 0.01)
                                     .forEach(d => items.push({
                                       date: `${d.day}日(${d.weekday})`,
                                       message: comparisonData.isFlex
                                         ? `FLEX残業NG: ${formatSpecialTime(d.sch.overtime)}h`
                                         : `差分: ${formatSpecialTime(d.diffOvertime)}h (勤務表:${formatSpecialTime(d.sch.overtime)} vs 日報:${formatSpecialTime(d.rep.overtime)})`
                                     }));
                                     
                                   // 45時間超過
                                   if (comparisonData.summary.isOvertimeLimitExceeded) {
                                     if (comparisonData.summary.totalOvertimeSch > 45.0) items.push({ date: '-', message: `勤務表の残業合計: ${formatSpecialTime(comparisonData.summary.totalOvertimeSch)}h (45h超過)` });
                                     if (comparisonData.summary.totalOvertimeSvc > 45.0) items.push({ date: '-', message: `服務簿の残業合計: ${formatSpecialTime(comparisonData.summary.totalOvertimeSvc)}h (45h超過)` });
                                     if (comparisonData.summary.totalOvertimeRep > 45.0) items.push({ date: '-', message: `日報の残業合計: ${formatSpecialTime(comparisonData.summary.totalOvertimeRep)}h (45h超過)` });
                                   }

                                   setNgDetailData({
                                     title: '残業不一致・超過 (詳細)',
                                     items: items,
                                     allItems: allNg,
                                     employeeName: currentEmployee.employeeName 
                                   });
                                 }}
                               >
                                 残業: {(comparisonData.summary.isOvertimeTotalMatch && !comparisonData.summary.isOvertimeLimitExceeded) ? 'OK' : 'NG'}
                                 {comparisonData.summary.isOvertimeLimitExceeded && <span className="block text-[9px] font-bold text-rose-600">45h超過</span>}
                               </div>
                             )}

                             {/* 夜業入力 */}
                             {comparisonData.summary.hasNightWorkRecord && (
                               <div 
                                 className={`p-2 rounded font-bold text-center border ${comparisonData.rows.every(d => Math.abs(d.diffNight) < 0.01 && !d.nightWorkCheckNG && !d.nightWorkMessage) ? 'bg-emerald-50 text-emerald-700 border-emerald-100' : 'bg-rose-50 text-rose-700 border-rose-100 cursor-pointer'}`}
                                 onClick={() => {
                                   if (comparisonData.rows.every(d => Math.abs(d.diffNight) < 0.01 && !d.nightWorkCheckNG && !d.nightWorkMessage)) return;
                                   const allNg = collectAllNgItems();
                                   if (allNg.length === 0) return;
                                   setNgDetailData({
                                     title: '夜業入力不備 (詳細)',
                                     items: comparisonData.rows
                                       .filter(d => Math.abs(d.diffNight) > 0.01 || d.nightWorkCheckNG || d.nightWorkMessage)
                                       .map(d => ({
                                         date: `${d.day}日(${d.weekday})`,
                                         message: [
                                           Math.abs(d.diffNight) > 0.01 ? `深夜時間差分: ${formatSpecialTime(d.diffNight)}h` : '',
                                           d.nightWorkCheckNG ? '日報夜業チェックNG' : '',
                                           d.nightWorkMessage
                                         ].filter(Boolean).join(', ')
                                       })),
                                     allItems: allNg,
                                     employeeName: currentEmployee.employeeName 
                                   });
                                 }}
                               >
                                 夜業入力: {comparisonData.rows.every(d => Math.abs(d.diffNight) < 0.01 && !d.nightWorkCheckNG && !d.nightWorkMessage) ? 'OK' : 'NG'}
                               </div>
                             )}

                             {/* 翌日非番 (管理職対応版) */}
                             {comparisonData.summary.hasNightWorkRecord && (
                               <div 
                                 className={`p-2 rounded font-bold text-center border ${
                                   (comparisonData.isManager || comparisonData.isDirector)
                                     ? (comparisonData.summary.hibanDays === 0 ? 'bg-emerald-50 text-emerald-700 border-emerald-100' : 'bg-rose-50 text-rose-700 border-rose-100 cursor-pointer')
                                     : (comparisonData.rows.every(d => d.nextDayCheckOK !== false) && !comparisonData.summary.saturdayHibanMismatch ? 'bg-emerald-50 text-emerald-700 border-emerald-100' : 'bg-rose-50 text-rose-700 border-rose-100 cursor-pointer')
                                 }`}
                                 onClick={() => {
                                   if (
                                     (comparisonData.isManager || comparisonData.isDirector)
                                       ? comparisonData.summary.hibanDays === 0
                                       : (comparisonData.rows.every(d => d.nextDayCheckOK !== false) && !comparisonData.summary.saturdayHibanMismatch)
                                   ) return;

                                   const allNg = collectAllNgItems();
                                   if (allNg.length === 0) return;
                                   
                                   // 表示用のアイテム生成（既存ロジック）
                                   let items = [];
                                   if (comparisonData.isManager || comparisonData.isDirector) {
                                      if (comparisonData.summary.hibanDays > 0) items = [{ date: '-', message: '管理職・取締役は非番を取得できません。' }];
                                   } else {
                                       comparisonData.rows.filter(d => d.nextDayCheckOK === false).forEach(d => {
                                         // 翌日の日付を取得するための処理を追加
                                         const nextDayRow = comparisonData.rows.find(row => row.day === d.day + 1);
                                         const dateStr = nextDayRow ? `${nextDayRow.day}日(${nextDayRow.weekday})` : `${d.day + 1}日`;
                                         items.push({ date: dateStr, message: '翌日が非番になっていません(夜業明け)' });
                                       });
                                       if (comparisonData.summary.saturdayHibanMismatch) {
                                           comparisonData.rows.filter(d => d.isSaturdayHibanNG).forEach(d => items.push({ date: `${d.day}日(${d.weekday})`, message: '土曜非番に対する月曜振休がありません' }));
                                       }
                                   }

                                   setNgDetailData({
                                     title: '翌日非番/土曜非番対応 (詳細)',
                                     items: items,
                                     allItems: allNg,
                                     employeeName: currentEmployee.employeeName 
                                   });
                                 }}
                               >
                                 翌日非番: {
                                    (comparisonData.isManager || comparisonData.isDirector)
                                      ? (comparisonData.summary.hibanDays === 0 ? 'OK' : 'NG')
                                      : (comparisonData.rows.every(d => d.nextDayCheckOK !== false) ? 'OK' : 'NG')
                                 }
                                 {(comparisonData.isManager || comparisonData.isDirector) && (
                                     <span className={`block text-[9px] font-normal ${comparisonData.summary.hibanDays === 0 ? 'text-slate-400' : 'text-rose-600 font-bold'}`}>
                                       {comparisonData.summary.hibanDays === 0 ? '非番登録なし' : '非番登録あり'}
                                     </span>
                                 )}
                                 {!(comparisonData.isManager || comparisonData.isDirector) && comparisonData.summary.saturdayHibanCount > 0 && (
                                   <span className={`block text-[9px] font-normal ${!comparisonData.summary.saturdayHibanMismatch ? 'text-slate-500' : 'text-rose-600 font-bold'}`}>
                                     土曜非番対応: {!comparisonData.summary.saturdayHibanMismatch ? 'OK' : 'NG'}
                                   </span>
                                 )}
                               </div>
                             )}

                             {/* 夜業突合 */}
                             {comparisonData.summary.hasNightWorkRecord && (
                               <div 
                                 className={`p-2 rounded font-bold text-center border ${!comparisonData.summary.nightWorkMismatch ? 'bg-emerald-50 text-emerald-700 border-emerald-100' : 'bg-rose-50 text-rose-700 border-rose-100 cursor-pointer'}`}
                                 onClick={() => {
                                   if (!comparisonData.summary.nightWorkMismatch) return;
                                   const allNg = collectAllNgItems();
                                   if (allNg.length === 0) return;
                                   setNgDetailData({
                                     title: '夜業/非番回数不一致 (詳細)',
                                     items: [
                                       { date: '-', message: `夜業回数: ${comparisonData.summary.nightWorkDays}回` },
                                       { date: '-', message: `非番回数: ${comparisonData.summary.hibanDays}回` },
                                       { date: '参考', message: '管理職以外は回数が一致する必要があります' }
                                     ],
                                     allItems: allNg,
                                     employeeName: currentEmployee.employeeName 
                                   });
                                 }}
                               >
                                 夜業突合: {!comparisonData.summary.nightWorkMismatch ? 'OK' : 'NG'} 
                                 <span className="block text-[9px] font-normal text-slate-500">(夜{comparisonData.summary.nightWorkDays}/非{comparisonData.summary.hibanDays})</span>
                               </div>
                             )}

                             {/* 振休残数管理 (突合の代わり) */}
                             {(comparisonData.summary.compInfo.initialStock !== 0 || comparisonData.summary.compInfo.earned !== 0 || comparisonData.summary.compInfo.used !== 0 || comparisonData.summary.compInfo.finalStock !== 0) && (
                               <div 
                                 className={`p-2 rounded font-bold text-center border ${comparisonData.summary.compInfo.warningUnused || comparisonData.summary.compInfo.warningShortage ? 'bg-rose-50 text-rose-700 border-rose-100 cursor-pointer' : 'bg-emerald-50 text-emerald-700 border-emerald-100'}`}
                                 onClick={() => {
                                   const allNg = collectAllNgItems();
                                   if (allNg.length === 0) return;
                                   // ここでは振休残数に関するエラーだけをピックアップして表示してもよいが、全体を見せる形にする
                                   setNgDetailData({
                                     title: '振休残数詳細',
                                     items: [
                                          { date: '期首残', message: `${comparisonData.summary.compInfo.initialStock}日` },
                                          { date: '発生', message: `${comparisonData.summary.compInfo.earned}日 (週休出・不算入)` },
                                          { date: '消化', message: `${comparisonData.summary.compInfo.used}日 (振休・振替休日)` },
                                          { date: '期末残', message: `${comparisonData.summary.compInfo.finalStock}日` },
                                          ...(comparisonData.summary.compInfo.warningUnused ? [{ date: '警告', message: '前月残が未消化です' }] : []),
                                          ...(comparisonData.summary.compInfo.warningShortage ? [{ date: '警告', message: '残数が不足しています' }] : [])
                                     ],
                                     allItems: allNg,
                                     employeeName: currentEmployee.employeeName 
                                   });
                                 }}
                               >
                                 振休残数: {comparisonData.summary.compInfo.finalStock}日
                                 <span className="block text-[9px] font-normal text-slate-500">
                                     (期首{comparisonData.summary.compInfo.initialStock}+発{comparisonData.summary.compInfo.earned}-消{comparisonData.summary.compInfo.used})
                                     {comparisonData.summary.compInfo.warningUnused && <span className="text-rose-600 block font-bold">未消化あり</span>}
                                     {comparisonData.summary.compInfo.warningShortage && <span className="text-rose-600 block font-bold">残数不足</span>}
                                 </span>
                               </div>
                             )}

                             {/* 深夜残業 (新規追加) */}
                             {comparisonData.summary.hasLateNightWorkCandidate && (
                               <div 
                                 className={`p-2 rounded font-bold text-center border ${comparisonData.rows.every(r => !r.lateNightOvertimeNG) ? 'bg-emerald-50 text-emerald-700 border-emerald-100' : 'bg-rose-50 text-rose-700 border-rose-100 cursor-pointer'}`}
                                 onClick={() => {
                                   if (comparisonData.rows.every(r => !r.lateNightOvertimeNG)) return;
                                   const allNg = collectAllNgItems();
                                   if (allNg.length === 0) return;
                                   setNgDetailData({
                                      title: '深夜残業不一致 (詳細)',
                                      items: comparisonData.rows
                                        .filter(r => r.lateNightOvertimeNG)
                                        .map(r => ({
                                          date: `${r.day}日(${r.weekday})`,
                                          message: `深夜時間不一致 (服務簿:${formatSpecialTime(r.svc.nightTime)}h vs 日報:${formatSpecialTime(r.rep.nightTime)}h) ※夜業以外で22時以降終了`
                                        })),
                                      allItems: allNg,
                                      employeeName: currentEmployee.employeeName
                                   });
                                 }}
                               >
                                 深夜残業: {comparisonData.rows.every(r => !r.lateNightOvertimeNG) ? 'OK' : 'NG'}
                               </div>
                             )}

                             {/* ログ乖離 */}
                             {comparisonData.summary.divergenceCount > 0 && (
                               <div 
                                 className="p-2 rounded font-bold text-center border bg-rose-50 text-rose-700 border-rose-100 cursor-pointer"
                                 onClick={() => {
                                   const allNg = collectAllNgItems();
                                   if (allNg.length === 0) return;
                                   setNgDetailData({
                                      title: 'ログ乖離あり (詳細)',
                                      items: comparisonData.rows
                                        .filter(r => r.svc.hasDivergence)
                                        .map(r => ({
                                          date: `${r.day}日(${r.weekday})`,
                                          message: '乖離有（申請要）'
                                        })),
                                      allItems: allNg,
                                      employeeName: currentEmployee.employeeName
                                   });
                                 }}
                               >
                                 ログ乖離: NG
                                 <span className="block text-[9px] font-bold text-rose-600">乖離あり</span>
                               </div>
                             )}

                             {/* 半休チェック (Ver.11.17.9) */}
                             {comparisonData.summary.hasHalfDayLeave && (
                               <div 
                                 className={`p-2 rounded font-bold text-center border ${comparisonData.rows.every(r => !(r.warningMessage && r.warningMessage.includes('半休'))) ? 'bg-emerald-50 text-emerald-700 border-emerald-100' : 'bg-rose-50 text-rose-700 border-rose-100 cursor-pointer'}`}
                                 onClick={() => {
                                   if (comparisonData.rows.every(r => !(r.warningMessage && r.warningMessage.includes('半休')))) return;
                                   const allNg = collectAllNgItems();
                                   if (allNg.length === 0) return;
                                   setNgDetailData({
                                      title: '半休時刻チェック (詳細)',
                                      items: comparisonData.rows
                                        .filter(r => r.warningMessage && r.warningMessage.includes('半休'))
                                        .map(r => ({
                                          date: `${r.day}日(${r.weekday})`,
                                          message: r.warningMessage
                                        })),
                                      allItems: allNg,
                                      employeeName: currentEmployee.employeeName
                                   });
                                 }}
                               >
                                 半休チェック: {comparisonData.rows.every(r => !(r.warningMessage && r.warningMessage.includes('半休'))) ? 'OK' : 'NG'}
                                 {!comparisonData.rows.every(r => !(r.warningMessage && r.warningMessage.includes('半休'))) && <span className="block text-[9px] font-bold text-rose-600">時刻重複あり</span>}
                               </div>
                             )}

                           </div>
                        </div>

                        {/* 数値サマリー（休暇を追加） */}
                        <div className="shrink-0 grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                          <div className="bg-white p-3 rounded-2xl border border-slate-200 shadow-sm relative overflow-hidden">
                            <div className="text-xs font-black text-slate-400 uppercase mb-1">所定内</div>
                            <div className="flex justify-between items-end mb-1">
                              <div><span className="text-[10px] text-slate-400 block">勤務表</span><span className="text-base font-mono font-bold text-slate-700">{formatSpecialTime(comparisonData.rows.reduce((acc, d) => acc + (d.sch.regularTime || 0), 0), 1)}</span></div>
                              <div className="text-center"><span className="text-[10px] text-slate-400 block">服務簿</span><span className="text-base font-mono font-bold text-indigo-700">{formatSpecialTime(comparisonData.rows.reduce((acc, d) => acc + (d.svc.regularTime || 0), 0), 1)}</span></div>
                              <div className="text-right"><span className="text-[10px] text-slate-400 block">日報</span><span className="text-base font-mono font-bold text-blue-600">{formatSpecialTime(comparisonData.rows.reduce((acc, d) => acc + (d.rep.regularTime || 0), 0), 1)}</span></div>
                            </div>
                          </div>
                          <div className="bg-white p-3 rounded-2xl border border-slate-200 shadow-sm relative overflow-hidden">
                            <div className="text-xs font-black text-slate-400 uppercase mb-1">残業</div>
                            <div className="flex justify-between items-end mb-1">
                              <div><span className="text-[10px] text-slate-400 block">勤務表</span><span className="text-base font-mono font-bold text-slate-700">{formatSpecialTime(comparisonData.rows.reduce((acc, d) => acc + (d.sch.overtime || 0), 0))}</span></div>
                              <div className="text-center"><span className="text-[10px] text-slate-400 block">服務簿</span><span className="text-base font-mono font-bold text-indigo-700">{formatSpecialTime(comparisonData.rows.reduce((acc, d) => acc + (d.svc.overtime || 0), 0))}</span></div>
                              <div className="text-right"><span className="text-[10px] text-slate-400 block">日報</span><span className="text-base font-mono font-bold text-blue-600">{formatSpecialTime(comparisonData.rows.reduce((acc, d) => acc + (d.rep.overtime || 0), 0))}</span></div>
                            </div>
                          </div>
                          <div className="bg-white p-3 rounded-2xl border border-slate-200 shadow-sm relative overflow-hidden">
                            <div className="text-xs font-black text-slate-400 uppercase mb-1">深夜</div>
                            <div className="flex justify-between items-end mb-1">
                              <div><span className="text-[10px] text-slate-400 block">勤務表</span><span className="text-base font-mono font-bold text-slate-700">{formatSpecialTime(comparisonData.rows.reduce((acc, d) => acc + (d.sch.nightTime || 0), 0))}</span></div>
                              <div className="text-center"><span className="text-[10px] text-slate-400 block">服務簿</span><span className="text-base font-mono font-bold text-indigo-700">{formatSpecialTime(comparisonData.rows.reduce((acc, d) => acc + (d.svc.nightTime || 0), 0))}</span></div>
                              <div className="text-right"><span className="text-[10px] text-slate-400 block">日報</span><span className="text-base font-mono font-bold text-blue-600">{formatSpecialTime(comparisonData.rows.reduce((acc, d) => acc + (d.rep.nightTime || 0), 0), 1)}</span></div>
                            </div>
                          </div>
                          <div className="bg-white p-3 rounded-2xl border border-slate-200 shadow-sm relative overflow-hidden">
                            <div className="text-xs font-black text-slate-400 uppercase mb-1">休暇</div>
                            <div className="flex justify-between items-end mb-1">
                               {(() => {
                                  return (
                                    <>
                                      <div className="text-center"><span className="text-[10px] text-slate-400 block">年休</span><span className="text-base font-mono font-bold text-slate-700">{comparisonData.summary.totalAnnualLeaveDays}d</span></div>
                                      <div className="text-center"><span className="text-[10px] text-slate-400 block">半休</span><span className="text-base font-mono font-bold text-slate-700">{comparisonData.summary.totalHalfPaidLeaveDays}d</span></div>
                                      <div className="text-center"><span className="text-[10px] text-slate-400 block">時間休</span><span className="text-base font-mono font-bold text-slate-700">{Math.floor(comparisonData.summary.totalTimeAnnualLeave)}h</span></div>
                                    </>
                                  );
                               })()}
                            </div>
                          </div>
                        </div>
                        
                        {currentEmployee.warnings && currentEmployee.warnings.length > 0 && (
                          <div className="shrink-0 mb-4 p-3 bg-red-100 border border-red-200 text-red-800 rounded-xl text-sm font-bold flex gap-2 items-center">
                            <AlertTriangle className="w-5 h-5"/>
                            重要警告: {currentEmployee.warnings.join(', ')}
                          </div>
                        )}

                        <div className="flex-1 bg-white rounded-3xl border border-slate-200 shadow-sm overflow-hidden flex flex-col min-h-0">
                          <div className="overflow-y-auto flex-1">
                            <table className="w-full text-left border-collapse">
                              <thead className="sticky top-0 bg-white z-10 shadow-sm">
                                <tr className="bg-slate-50 text-sm font-black text-slate-400 uppercase tracking-widest"><th className="px-2 py-2 w-20 text-center">Date</th><th className="px-2 py-2 border-l bg-slate-100/50">項目</th><th className="px-2 py-2 border-l">勤務表</th><th className="px-2 py-2 border-l text-indigo-700 bg-indigo-50/30 w-48">服務簿</th><th className="px-2 py-2 border-l">日報</th><th className="px-2 py-2 border-l text-center w-24">差異</th></tr>
                              </thead>
                              <tbody className="divide-y divide-slate-100 text-sm">
                                {comparisonData.rows.map(({ day, weekday, rowColor, sch, rep, svc, diffOvertime, diffRegular, diffNight, hasHolidayWork, hasNightWork, isSpecialCase, warningMessage, nextDayCheckOK, nightWorkCheckOK, nightWorkCheckNG, nightWorkMessage, statusBadge, lateNightOvertimeNG }) => {
                                  let schStatusColor = 'bg-slate-100 text-slate-600', schS = sch.status || '';
                                  if (schS.includes('時間年休') || schS.includes('半休')) schStatusColor = 'bg-orange-100 text-orange-800'; else if (schS.includes('休') || schS.includes('非番')) schStatusColor = 'bg-rose-100 text-rose-800';
                                  const isFlex = comparisonData.isFlex;
                                  let svcStatus = svc.status || '', svcStatusColor = 'bg-indigo-100 text-indigo-700', typesStr = '';
                                  if (svc.types && svc.types.length > 0) { typesStr = svc.types.join(', '); if (svcStatus) svcStatus += ` [${typesStr}]`; else svcStatus = typesStr; }
                                  if (typesStr.includes('非番勤務')) svcStatusColor = 'bg-orange-200 text-orange-900'; else if (typesStr.includes('時間年休') || typesStr.includes('半休')) svcStatusColor = 'bg-orange-100 text-orange-800'; else if (typesStr.includes('年休') || typesStr.includes('全日年休') || typesStr.includes('有給') || typesStr.includes('非番') || typesStr.includes('振休') || typesStr.includes('振替休日') || typesStr.includes('その他休')) svcStatusColor = 'bg-rose-100 text-rose-800';
                                  return (
                                    <tr key={day} className={`hover:opacity-80 transition-colors ${rowColor} ${warningMessage ? 'bg-amber-50' : ''}`}>
                                      <td className="px-2 py-2 font-mono font-bold text-slate-500 text-center text-xl">{day} <span className="text-sm ml-1">{weekday}</span></td>
                                      <td className="px-2 py-2 border-l bg-slate-100/50"><div className="flex flex-col gap-0.5"><span className="row-h text-xs font-bold text-slate-400 uppercase">ステータス</span><span className="row-h text-xs font-bold text-slate-400 uppercase">時間帯</span><span className="row-h text-xs font-bold text-slate-400 uppercase">所定内</span><span className="row-h text-xs font-bold text-slate-400 uppercase">時間外</span><span className="row-h text-xs font-bold text-slate-400 uppercase">深夜</span><span className="row-h text-xs font-bold text-slate-400 uppercase">時間年休</span></div></td>
                                      <td className="px-2 py-2 border-l"><div className="flex flex-col gap-0.5"><div className="row-h flex gap-1">{sch.status && <span className={`text-[10px] px-2 py-0.5 rounded font-bold ${schStatusColor}`}>{sch.status}</span>}{sch.special?.includes('夜業') && <span className="text-[10px] px-2 py-0.5 rounded font-bold bg-yellow-900 text-white">夜業</span>}</div><div className="row-h font-mono text-slate-600">{sch.startTime ? `${sch.startTime}-${sch.endTime}` : '-'}</div><div className="row-h font-mono font-bold text-slate-700">{formatSpecialTime(sch.regularTime)}</div><div className="row-h font-mono font-bold text-slate-700">{formatSpecialTime(sch.overtime)}</div><div className="row-h font-mono text-slate-400">{formatSpecialTime(sch.nightTime)}</div><div className="row-h font-mono text-slate-400 text-xs">{sch.timeAnnualLeave > 0 ? formatSpecialTime(sch.timeAnnualLeave) : '-'}</div></div></td>
                                      <td className="px-2 py-2 border-l bg-indigo-50/10"><div className="flex flex-col gap-0.5"><div className="row-h flex gap-1 overflow-hidden" title={svcStatus}>{svcStatus && <span className={`text-[10px] px-2 py-0.5 rounded font-bold truncate max-w-full ${svcStatusColor}`}>{svcStatus}</span>}</div><div className="row-h font-mono text-slate-600">{svc.startTime ? `${svc.startTime}-${svc.endTime}` : '-'}</div><div className="row-h font-mono font-bold text-indigo-700">{formatSpecialTime(svc.regularTime)}</div><div className="row-h font-mono font-bold text-indigo-700">{formatSpecialTime(svc.overtime)}</div><div className="row-h font-mono text-slate-400">{formatSpecialTime(svc.nightTime)}</div><div className="row-h font-mono font-bold text-indigo-700">{svc.timeAnnualLeave > 0 ? (<span>{formatSpecialTime(svc.timeAnnualLeave)}{svc.timeAnnualLeaveDetails && <span className="text-[9px] ml-1 font-normal text-slate-500">({svc.timeAnnualLeaveDetails})</span>}</span>) : '-'}</div></div></td>
                                      <td className="px-2 py-2 border-l"><div className="flex flex-col gap-0.5"><div className="row-h flex gap-1">{hasHolidayWork && <span className="text-[10px] px-2 py-0.5 rounded font-bold bg-amber-100 text-amber-700">休出あり</span>}{hasNightWork && <span className="text-[10px] px-2 py-0.5 rounded font-bold bg-yellow-900 text-white">夜業</span>}{rep.nightWorkVal && <span className="text-[10px] px-2 py-0.5 rounded font-bold bg-emerald-100 text-emerald-700">夜業{rep.nightWorkVal}</span>}</div><div className="row-h font-mono text-slate-400 text-xs">{rep.startTime ? '記録あり' : '-'}</div><div className="row-h font-mono font-bold text-blue-600">{formatSpecialTime(rep.regularTime)}</div><div className="row-h font-mono font-bold text-blue-600">{formatSpecialTime(rep.overtime)}</div><div className="row-h font-mono text-slate-400">{formatSpecialTime(rep.nightTime)}</div><div className="row-h flex gap-1 text-[9px]"></div></div></td>
                                      <td className="px-2 py-2 border-l text-center align-middle"><div className="flex flex-col gap-0.5 items-center justify-center h-full"><div className="row-h flex items-center justify-center gap-1 text-[10px] font-bold">{statusBadge && <span className="px-1.5 py-0.5 rounded bg-blue-100 text-blue-600 border border-blue-200 whitespace-nowrap">{statusBadge}</span>}<span className="text-rose-500">{nightWorkCheckNG && '日報夜業チェックNG'}{nightWorkCheckOK && <span className="text-emerald-500">夜業1OK</span>}{nextDayCheckOK===false && '翌NG'}{nightWorkMessage && <span className="text-rose-600">{nightWorkMessage}</span>}{lateNightOvertimeNG && <span className="text-rose-600 block">深夜残業NG</span>}</span></div><div className="row-h text-[10px] font-bold text-rose-600">{svc.hasDivergence && '乖離有'}</div><div className={`row-h font-mono font-bold flex items-center gap-1 ${Math.abs(diffRegular) > 0.01 || warningMessage ? (warningMessage ? 'text-amber-600' : 'text-rose-600') : 'text-emerald-600'}`}>{Math.abs(diffRegular) > 0.01 ? formatSpecialTime(diffRegular) : (isSpecialCase ? <span className="text-[10px] bg-emerald-100 text-emerald-600 px-1 rounded">夜業OK</span> : (warningMessage ? '確認' : 'OK'))}{warningMessage && <span title={warningMessage} className="text-amber-500 cursor-help"><AlertTriangle className="w-4 h-4"/></span>}</div><div className={`row-h font-mono font-bold ${Math.abs(diffOvertime) > 0.01 ? 'text-rose-600' : 'text-emerald-600'}`}>{isFlex ? (sch.overtime > 0 ? 'NG' : 'OK') : (Math.abs(diffOvertime) > 0.01 ? formatSpecialTime(diffOvertime) : 'OK')}</div><div className={`row-h font-mono font-bold ${Math.abs(diffNight) > 0.01 ? 'text-rose-600' : 'text-emerald-600'}`}>{Math.abs(diffNight) > 0.01 ? formatSpecialTime(diffNight) : 'OK'}</div><div className="row-h"></div></div></td>
                                    </tr>
                                  );
                                })}
                              </tbody>
                            </table>
                          </div>
                        </div>
                      </>
                    )}
                  </div>
                </div>
              </div>
            )}
          </main>
          <SettingsModal isOpen={showSettings} onClose={() => setShowSettings(false)} settings={settings} onSave={handleSaveSettings} onClear={handleClearSettings} onExportNextMonth={handleExportNextMonthSettings} />
          <HelpModal isOpen={showHelp} onClose={() => setShowHelp(false)} />
          <NgDetailModal isOpen={!!ngDetailData} onClose={() => setNgDetailData(null)} title={ngDetailData?.title} items={ngDetailData?.items || []} allItems={ngDetailData?.allItems} employeeName={ngDetailData?.employeeName} />
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
